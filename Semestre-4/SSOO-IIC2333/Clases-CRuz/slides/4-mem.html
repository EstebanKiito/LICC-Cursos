<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Administración de Memoria</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>Administración de Memoria</h1><p>Semestre 2022-1<br/>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación<br/>Pontificia Universidad Católica de Chile</p></section><section><h2>Memoria</h2><section id="memory0"><h3>Direcciones de Memoria</h3><div><ul><li>Un gran arreglo de <i>bytes</i></li><li>Cada uno con su propia <b>dirección</b></li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><div>Sin multiprogramación &hellip;</div><img src="../images/figures/02-memory-old.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /></div><div class="fragment" style="width:50%; vertical-align:middle; display:inline-block;"><div>Con multiprogramación &hellip;</div><img src="../images/figures/02-memory-new.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="35%" /></div></section><section data-transition="fade-out"><h3>Direcciones de Memoria</h3><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Con solamente un proceso en memoria &hellip;</div><pre><code class="hljs asm"> mov %eax, 0x10001       ; a += 3
 add %eax, $0x3
 mov 0x10001, %eax</code></pre><div>La vida del compilador es (más) fácil</div><br /><br /><ul><li>Programa siempre se carga en la misma dirección</li><li>Cada variable tiene la misma dirección en memoria en cada ejecución</li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-memory-old.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="60%" /></div></section><section data-transition="fade-in fade-out"><h3>Direcciones de Memoria</h3><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Con múltiples procesos en memoria (<i>multiprogramación</i>) &hellip;</div><pre><code class="hljs asm"> mov %eax, 0x10001       ; falla si a no está en 0x10001
 add %eax, $0x3
 mov 0x10001, %eax</code></pre><div>Procesos pueden cargarse en cualquier parte de la memoria</div><br /><br /><div>Problema 1:</div><ul><li>Variables no están siempre en la misma ubicación</li><li>Requisito: <b>relocalización de variables</b></li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-memory-new.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="60%" /></div></section><section data-transition="fade-in fade-out"><h3>Direcciones de Memoria</h3><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Con múltiples procesos en memoria (<i>multiprogramación</i>) &hellip;</div><pre><code class="hljs asm"> mov %eax, 0x20001       ; 0x20001 es memoria de C
 add %eax, $0x3
 mov 0x20001, %eax</code></pre><div>Procesos pueden cargarse en cualquier parte de la memoria</div><br /><br /><div>Problema 2:</div><ul><li>Un proceso, por error, podría leer memoria y modificar memoria de otro proceso</li><li>Requisito: <b>protección de memoria</b></li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-memory-new.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="60%" /></div></section><section data-transition="fade-in fade-out"><h3>Direcciones de Memoria</h3><div style="width:40%; vertical-align:middle; display:inline-block;"><div><b>Direcciones absolutas no sirven con multiprogramación</b></div><ul><li>Caso (a). Un proceso único en memoria, de 16KB, cargado en 0.</li><li>Caso (b). Otro proceso único en memoria, de 16KB, cargado en 0.</li><li>Caso (c). Dos procesos de 16KB cargados en memoria, de manera contigua.</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/04-spaces.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="75%" /></div></section><section data-transition="fade-in"><h3>Relocalización y protección</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Direcciones absolutas no sirven con multiprogramación</b></div><ul><li>Caso (b). Instrucción <code>JMP 28</code> está OK si el proceso está cargado en 0.</li><li>Caso (c). Si el proceso se carga en <code>16384</code., hay que cambiar <code>JMP 28</code> por <code>JMP 16412</code>.</li><li>¿Cómo conseguirlo?</li><ul class="fragment"><li>Compilador podría generar: <code>JMP 28+X</code> </li><li>Al cargar en memoria se determina que <code>X</code> es 16384, y se carga en memoria <code>JMP 16412</code></li><li>Ejecutar esto cada vez que se cargue</li></ul></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/04-spaces.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="75%" /></div></section><section><h3>Direcciones de memoria</h3><div>¿Cómo podemos saber donde se ubica nuestro código?</div><div style="width:60%; vertical-align:middle; display:inline-block;"><pre><code class="hljs lang-c"> #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;

 int b = 3;

 int main(int argc, char *argv[]) {
   int x=3;
   printf("Location of code   : %p\n", (void *)main);
   printf("Location of data   : %p\n", (void *)&b);
   printf("Location of heap   : %p\n", (void *)malloc(1));
   printf("Location of stack  : %p\n", (void *)&x);
   return x+b;
 }</code></pre><div class="fragment">Código completo <a href="../examples/mems.c" target="_blank">aquí</a></div><div class="fragment">Atención: estas direcciones son <b>virtuales</b> &#x1f632;</div></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-memory-sections.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="75%" /></div></section></section><section><h2>Espacios de direcciones</h2><section><div>Dos problemas: (1)<b>relocalización</b> y (2)<b>protección</b></div><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;">Abstracción: <b>espacios de direcciones</b></blockquote><div class="fragment" data-fragment-index="2" style="width:60%; vertical-align:middle; display:inline-block;"><div>CPUs desde CDC6600 hasta Intel 8088 integran dos registros: <code>base</code> y <code>limit</code><br/><br/></div><ul><li>Al cargar cada procesos se cargan estos registros</li><li>Proceso quiere ejecutar <code>JMP 28</code></li><li>Pero <i>hardware</i> ejecuta <code>JMP 28+16384</code></li><li>Si la dirección es mayor que <code>limit</code>, se genera un <i>trap</i></li><li>MMU: <b>Memory Manager Unit</b></li></ul><div class="fragment" data-fragment-index="3">¿Resuelto?</div></div><div class="fragment" data-fragment-index="2" style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/04-twoprocs.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="70%" /></div></section><section><div>Proceso mantiene un espacio <b>único</b> y <b>secuencial</b> (lineal) de direcciones.</div><div style="width:60%; vertical-align:middle; display:inline-block;"><ul><li>Proceso $A$ utiliza 16KB.</li><ul><li><code>code</code> en 0-1023</li><li><code>heap</code> empieza en 1024, y crece</li><li><code>stack</code> empieza en 16383, y decrece</li></ul><li>Al cargarlo en memoria, el sistema operativo asigna <code>Base: 4096</code>, <code>limit: 16384</code>.</li><ul><li>Código de $A$ no es modificado</li><li>Proceso $A$ pide la dirección <b>virtual</b>: 768</li><li>MMU entrega la dirección <b>física</b>: 4864</li></ul></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-memory-inside.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Sobrecarga de memoria</h3><div>¿Cuántos procesos caben en memoria? ¿Qué pasa si la memoria se llena?</div><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;"> Operaciones de <b>swapping</b></blockquote><div class="fragment" data-fragment-index="2" style="width:60%; vertical-align:middle; display:inline-block;"><ul><li><b>Swap-out</b>. Memoria del proceso se copia a disco.</li><li><b>Swap-in</b>. Memoria del proceso se copia de disco a memoria.</li></ul><div class="fragment" data-fragment-index="3">¿Qué pasa con la relocalización?</div></div><div class="fragment" data-fragment-index="2" style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-8_05.pdf.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="80%" /></div></section><section><div>Procesos pueden ser cargados y descargados de la memoria</div><img src="../images/figures/04-loadprocs.png" width="50%" style="border:none; box-shadow:none;" alt="04 loadprocs" /><div>Memoria del sistema queda con huecos</div><div class="fragment">¿Qué hacer con los huecos?</div></section><section><div>¿Qué hacer con los huecos?</div><img src="../images/figures/02-compact.png" width="35%" style="border:none; box-shadow:none;" alt="02 compact" /><br /><div style="width:60%; vertical-align:middle; display:inline-block;"><div><b>Compactación</b>: Fusionar los huecos</div><ul class="fragment" data-fragment-index="2"><li>Requiere copiar memoria a otras direcciones</li><li>Caro. No se hace.</li><li class="fragment" data-fragment-index="3"><i>Mejor</i>: asignar espacios de manera que no se necesite compactar</li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img class="fragment" data-fragment-index="1" src="../images/figures/02-fusion.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="50%" /></div></section><section><div>¿Como evitar espacios libres?</div><div>Estrategias:</div><ul><li><strong>First-fit</strong>. En el primer lugar disponible.</li><li><strong>Best-fit</strong>. En el que deja menos espacio libre (el más pequeño posible).</li><li><strong>Worst-fit</strong>. En el que deja más espacio libre (el más grande).</li></ul><div><div style="width:25%; vertical-align:middle; display:inline-block;"><img class="fragment" data-fragment-index="1" src="../images/figures/02-fits.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="24%" /></div><div style="width:25%; vertical-align:middle; display:inline-block;"><img class="fragment" data-fragment-index="2" src="../images/figures/02-fits-first.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="25%" /></div><div style="width:25%; vertical-align:middle; display:inline-block;"><img class="fragment" data-fragment-index="3" src="../images/figures/02-fits-best.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="25%" /></div><div style="width:25%; vertical-align:middle; display:inline-block;"><img class="fragment" data-fragment-index="4" src="../images/figures/02-fits-worst.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="23%" /></div></div></section><section><h3>Fragmentación</h3><div>Con cualquier estrategia aún pueden quedar espacios libres no contiguos.</div><blockquote style="background:#B7E1CD;"><b>Fragmentación Externa</b>. Espacios libres no contiguos.</blockquote><ul class="fragment"><li>Compactar no es una opción práctica</li><li>Supuesto: procesos se pueden reubicar en cualquier parte de la memoria </li><li>Supuesto: procesos deben ubicarse en espacios <b>contiguos</b></li></ul></section></section><section id="segmentation"><h2>Segmentación</h2><section><div>Problema: un espacio de direcciones muy grande.</div><blockquote class="fragment" data-fragment-index="1" style="background:#F4C7C3;"><b>Segmentación</b></blockquote><div class="fragment" data-fragment-index="2">Se divide el espacio de direcciones en varios espacios más pequeños</div><ul class="fragment" data-fragment-index="2"><li>Espacios más pequeños pueden ser asignados más fácilmente</li></ul><div class="fragment" data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Segmento:</b> espacio de direcciones contiguo</div><ul><li>Ejemplo: código, datos, heap, stack, &hellip;</li></ul></div><div class="fragment" data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-basic-segments.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="80%" /></div></section><section><h3>Implementando segmentación</h3><div>Ahora hay varios espacios lineales de direcciones.</div><div style="width:50%; vertical-align:middle; display:inline-block;"><div>MMU debe ser capaz de hacer la traducción</div><table><tr><td>Segment</td><td>Base</td><td>Size </td></tr><tr><td><code>code</code></td><td>32768 (32KB)</td><td>2048 (2KB)</td></tr><tr><td><code>heap</code></td><td>34816 (34KB)</td><td>2048 (2KB)</td></tr><tr><td><code>stack</code></td><td>28672 (28KB)</td><td>2048 (2KB)</td></tr></table><div><b>Tabla de Segmentos</b></div><ul class="fragment"><li>Dirección virtual (lógica): $100$</li><ul><li>Está en segmento <code>code</code></li><li>Base + dirección $= 32768 + 100 = 32868$</li></ul><li>Dirección física: $32868$</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-segments-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /><div style="width:10%; vertical-align:middle; display:inline-block;"></div><img src="../images/figures/02-segments-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="23%" /></div></section><section><h3>Implementando segmentación</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><table><tr><td>Segment</td><td>Base</td><td>Size </td></tr><tr><td><code>code</code></td><td>32768 (32KB)</td><td>2048 (2KB)</td></tr><tr><td><code>heap</code></td><td>34816 (34KB)</td><td>2048 (2KB)</td></tr><tr><td><code>stack</code></td><td>28672 (28KB)</td><td>2048 (2KB)</td></tr></table><br /><ul class="fragment"><li>Dirección virtual (lógica): $4200$</li><ul><li>Está en segmento <code>heap</code></li><li>Base + dirección $= 34816 + 4200 = 39016$</li></ul><li>Dirección física: $39016$</li></ul><blockquote class="fragment" style="background:#F4C7C3;"><code>Segmentation Fault!</code></blockquote></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-segments-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /><div style="width:10%; vertical-align:middle; display:inline-block;"></div><img src="../images/figures/02-segments-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="23%" /></div></section><section><h3>Implementando segmentación</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><table><tr><td>Segment</td><td>Base</td><td>Size </td></tr><tr><td><code>code</code></td><td>32768 (32KB)</td><td>2048 (2KB)</td></tr><tr><td><code>heap</code></td><td>34816 (34KB)</td><td>2048 (2KB)</td></tr><tr><td><code>stack</code></td><td>28672 (28KB)</td><td>2048 (2KB)</td></tr></table><br /><ul class="fragment"><li>Dirección virtual (lógica): $4200$</li><ul><li>Está en segmento <code>heap</code></li><li><i>Offset</i> dentro de <code>heap</code>: $4200-\mathbf{4096}=104$</li><li>Base + <i>offset</i> $= 34816 + 104 = 34920$</li></ul><li>Dirección física: $34920$</li></ul><br /><br /><div class="fragment">¿Cómo conozco el segmento? ¿y el offset?</div></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-segments-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /><div style="width:10%; vertical-align:middle; display:inline-block;"></div><img src="../images/figures/02-segments-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="23%" /></div></section><section><h3>Implementando segmentación</h3><div>¿Cómo conocer segmento y <i>offset</i>?</div><ul><li>Se pueden hacer restas &hellip; </li><li>Pero la lógica de bit es más rápida</li></ul><br /><div class="fragment">Ejemplo: ¿cuántos bit necesitamos para identificar 3 segmentos? <span class="fragment">$\rightarrow 2$</span></div><img class="fragment" src="../images/figures/02-segment-bits.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="30%" /><br /><div class="fragment" style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Dirección virtual: $4200 = 0b01 0000 0110 1000 = 0x1068$</li><ul><li>Bits de segmento: $0b01 = 1 = 0x1$</li><li>Bits de offset: $0b0000 0110 1000 = 104 = 0x068$</li></ul></ul></div><div class="fragment" style="width:50%; vertical-align:middle; display:inline-block;"><pre><code class="hljs lang-c"> SEG_MASK = 0x3000;
 OFFSET_MASK = 0xFFF;
 SEG_SHIFT = 12;
 virtualAddress = 4200;
 segment = (virtualAddress & SEG_MASK) >> SEG_SHIFT;
 offset = virtualAddress & OFFSET_MASK;
 if(offset >= size[segment])
   raise(SEG_FAULT);
 else
   physicalAddress = base[segment] + offset;</code></pre></div></section><section><h3>Implementando segmentación</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><table><tr><td>Segment</td><td>Base</td><td>Size </td></tr><tr><td><code>code</code></td><td>32768 (32KB)</td><td>2048 (2KB)</td></tr><tr><td><code>heap</code></td><td>34816 (34KB)</td><td>2048 (2KB)</td></tr><tr><td><code>stack</code></td><td>28672 (28KB)</td><td>2048 (2KB)</td></tr></table><div><b>Atención con el <i>stack</i></b>.</div><ul class="fragment"><li>Dirección virtual (lógica): $16300$</li><ul><li>Segmento <code>stack</code> (segmento 3)</li><li>Base + <i>offset</i> $= 28672 + 4012 = 32684$</li></ul><li>Dirección física: $32684$ &#x274c;</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-segments-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /><div style="width:10%; vertical-align:middle; display:inline-block;"></div><img src="../images/figures/02-segments-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="23%" /></div></section><section><h3>Implementando segmentación</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><div>Otro campo en la tabla de segmentos</div><table><tr><td>Segment</td><td>Base</td><td>Size </td><td>Upwards</td></tr><tr><td><code>code</code></td><td>32768 </td><td>2048 </td><td>1</td></tr><tr><td><code>heap</code></td><td>34816 </td><td>2048 </td><td>1</td></tr><tr><td><code>stack</code></td><td>28672 </td><td>2048 </td><td>0</td></tr></table><ul class="fragment"><li>Dirección virtual (lógica): $16300$</li><ul><li>Segmento <code>stack</code> (segmento 3)</li><li><i>Offset</i>: complemento de 4096 (4KB, máximo offset). $4012-4096=-84$</li><li>Base + <i>offset</i> $= 28672 - 84 = 28588$</li></ul><li>Dirección física: $28588$ &#x2714;</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-segments-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /><div style="width:10%; vertical-align:middle; display:inline-block;"></div><img src="../images/figures/02-segments-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="23%" /></div></section><section><h3>Visualizando segmentos</h3><div>Comando <code>pmap</code> permite ver segmentos asignados a un proceso</div><pre><code class="hljs bash"> pmap -x [PID]</code></pre><div>Atención: necesita un proceso en ejecución</div></section><section><h3>Fragmentación</h3><div>Implementamos segmentación para eliminar fragmentación externa</div><blockquote style="background:#B7E1CD;"><b>Fragmentación Externa</b>. Espacios libres no contiguos.</blockquote><div style="width:50%; vertical-align:middle; display:inline-block;"><ul class="fragment"><li>Menos fragmentación &hellip; pero sigue existiendo</li><li>Difícil anticipar los tamaños de los segmentos</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-fragments-ram.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="35%" /></div></section></section><section id="pagination"><h2>Paginación</h2><section><div>Problema: un espacio de direcciones muy grande.</div><ul><li>Idea 1: Dividir el espacio de direcciones en <b>segmentos</b></li><li class="fragment" data-fragment-index="1">Idea 2: Que los segmentos sean del mismo tamaño: <b>páginas de memoria</b></li></ul><blockquote class="fragment" data-fragment-index="2" style="background:#F4C7C3;"><b>Paginación</b></blockquote><div class="fragment" data-fragment-index="2" style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Espacio virtual: <b>páginas</b></li><li>Espacio físico: <i><b>frames</b></i> (marcos)</li><li>Páginas y <i>frames</i> del <b>mismo</b> tamaño</li></ul><br /><br /><div class="fragment" data-fragment-index="3">Sistema con 128B RAM</div><ul class="fragment" data-fragment-index="3"><li>Espacio virtual (lógico) de 64B.</li><li>Espacio físico de 128B.</li><li>Páginas (y <i>frames</i>) de 16B.</li></ul></div><div class="fragment" data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-pages-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="50%" /><img src="../images/figures/02-pages-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="50%" /></div></section><section><ul><li>Sistema necesita llevar registro de páginas asignadas a cada proceso</li><li>Sistema necesita información para traducir direcciones virtuales a físicas</li></ul><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;"><b>Tabla de Páginas</b></blockquote><div class="fragment" data-fragment-index="2" style="width:70%; vertical-align:middle; display:inline-block;"><div class="fragment" data-fragment-index="2">Páginas de 16B, espacio virtual 64B, espacio físico 128B.</div><ul><li class="fragment" data-fragment-index="3">Direcciones posibles en una página: $16 = 2^4$<span class="fragment" data-fragment-index="4">$\rightarrow 4$ bit.</span></li><ul class="fragment" data-fragment-index="5" style="font-size:32px;"><li>4 bit indican el <i>offset</i> dentro de una página.</li></ul><li class="fragment" data-fragment-index="6">Espacio virtual de $64=2^6$ Byte. Requiere $6$ bit.</li><ul class="fragment" data-fragment-index="7" style="font-size:32px;"><li>2 bit indican el número de página (VPN).</li><li>Páginas posibles: $2^2=4$ entradas en la tabla de páginas</li></ul><li class="fragment" data-fragment-index="8">Espacio virtual de $128=2^7$ Byte. Require $7$ bit.</li><ul class="fragment" data-fragment-index="9" style="font-size:32px;"><li>3 bit indican el número de <i>frame</i> (PFN).</li><li><i>Frames</i> en la memoria principal: $2^3=8$ <i>frames</i></li></ul></ul><br /><br /><div class="fragment" data-fragment-index="10">Traducción VPN$\to$PFN en la Tabla de Páginas</div></div><div class="fragment" data-fragment-index="2" style="width:30%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-page-translation.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="70%" /></div></section><section><h3>Tabla de Páginas</h3><div>Páginas de 16B, espacio virtual 64B, espacio físico 128B.</div><div class="fragment" data-fragment-index="1" style="width:100%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-pages-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="30%" /><div style="display:inline-block;">&nbsp; &nbsp; &nbsp; </div><img src="../images/figures/02-page-translation.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="20%" /><div style="display:inline-block;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><img src="../images/figures/02-pages-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="25%" /></div><div class="fragment" data-fragment-index="2" style="width:50%; vertical-align:middle; display:inline-block;"><table style="font-size:28px;"><tr><td>Page (VPN)</td><td>Frame (PFN)</td></tr><tr><td>0 (0b00) </td><td>3 (0b011)</td></tr><tr><td>1 (0b01)</td><td>7 (0b111)</td></tr><tr><td>2 (0b10)</td><td>5 (0b101)</td></tr><tr><td>3 (0b11)</td><td>2 (0b010)</td></tr></table></div><div class="fragment" data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;"><div>Dirección virtual: $21\; (0b010101)$</div><ul class="fragment" data-fragment-index="4" style="font-size:28px;"><li>#Página: $1\; (0b01)$</li><li><i>Offset</i>: $5\; (0b0101)$</li><li>Tabla: $1 \rightarrow 7$</li></ul><div class="fragment" data-fragment-index="5">Dirección física: $117\; (0b1110101)$</div></div></section><section><h3>Tabla de Páginas</h3><div>Páginas de 4KB, dirección virtual de 16 bit, dirección física de 15 bit.</div><div class="fragment" data-fragment-index="2" style="width:65%; vertical-align:middle; display:inline-block;"><div><b>Dimensiones</b></div><ul><li>Tamaño de espacio virtual: <span class="fragment" data-fragment-index="3">$2^{16} \text{B} =65536 \text{B} = 64\text{KB}$</span></li><li>Tamaño de espacio físico: <span class="fragment" data-fragment-index="4">$2^{15} \text{B} =32768 \text{B} = 32\text{KB}$</span></li><li>Tamaño de página: <span class="fragment" data-fragment-index="5">$4\text{KB}=2^2\times2^{10}\text{B}= 2^{12}\text{B}$</span></li><li>Bits para <i>offset</i>: <span class="fragment" data-fragment-index="6">$12$ (rango: $0x000$ a $0xFFF$)</span></li><li>Bits para #página: <span class="fragment" data-fragment-index="7">$4$ (16 páginas)</span></li><li>Bits para #frame: <span class="fragment" data-fragment-index="8">$3$ (8 frames)</span></li></ul><div><b>Traducción</b></div><ul><li>Dirección lógica: $8196\; (0x2004)$</li><ul class="fragment" data-fragment-index="9"><li>#Página: 2</li><li>#Frame: 6</li></ul><li>Dirección física: <span class="fragment" data-fragment-index="10">$24580\; (0x6004)$</span></li></ul></div><div class="fragment" data-fragment-index="1" style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-page-translation-big.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /><br /><div style="font-size:16px;">Ignoramos el "present/absent" bit, &hellip; por ahora</div></div></section><section data-transition="fade-out"><blockquote style="background:#B7E1CD;"><b>¿De qué tamaño es una tabla de páginas?</b></blockquote><ul class="fragment" data-fragment-index="1"><li>Arquitectura con espacio de direcciones virtuales de 32 bit</li><li>Páginas de $4$KB. $20$ bit para #página, $12$ bit para <i>offset</i></li><li>¿Cuántas páginas? $2^{20}$. Tabla de páginas necesita $2^{20}$ entradas (filas, o PTE, <i>Page Table Entry</i>)</li></ul><blockquote class="fragment" data-fragment-index="2" style="background:#B7E1CD;"> <b>¿De qué tamaño es una entrada en la tabla de páginas?</b></blockquote><div class="fragment" data-fragment-index="3">Al menos necesita los bit para el #<i>frame</i>. Si el espacio físico es de 32 bit, necesita $20$ bit.</div><div class="fragment" data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block; font-size:16px;"><img src="../images/figures/02-pte.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div><div class="fragment" data-fragment-index="3" style="width:10%; vertical-align:middle; display:inline-block; font-size:16px;">PTE en x86</div><ul class="fragment" data-fragment-index="4" style="font-size:24px;"><li><code>V</code>, <b>valid bit</b> (no está en la imagen), indica si la página ha sido asignada</li><li><code>P</code>, <b>present bit</b>, indica si la página está en memoria o en disco.</li><li><code>RW</code>, <b>read/write bit</b>, indica si se puede escribir</li><li><code>U/S</code>, user-supervisor bit, indica si se puede acceder en <i>user-mode</i></li><li><code>PWT</code>, <code>PCD</code>, <code>PAT</code>, <code>G</code>, controlan el <i>caching</i></li><li><code>A</code>, <b>accessed bit</b>, o <b>reference bit</b> indica si la página ha sido leída</li><li><code>D</code>, <b>dirty bit</b>, indica si la página ha sido modificada</li></ul></section><section data-transition="fade-in"><blockquote style="background:#B7E1CD;"><b>¿De qué tamaño es una tabla de páginas?</b></blockquote><ul><li>Arquitectura con espacio de direcciones virtuales de 32 bit</li><li>Páginas de $4$KB. $20$ bit para #página, $12$ bit para <i>offset</i></li><li>¿Cuántas páginas? $2^{20}$. Tabla de páginas necesita $2^{20}$ entradas (filas, o PTE, <i>Page Table Entry</i>)</li></ul><blockquote style="background:#B7E1CD;"> <b>¿De qué tamaño es una entrada en la tabla de páginas?</b></blockquote><div>Al menos necesita los bit para el #<i>frame</i>. Si el espacio físico es de 32 bit, necesita $20$ bit.</div><div style="width:50%; vertical-align:middle; display:inline-block; font-size:16px;"><img src="../images/figures/02-pte.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div><div style="width:10%; vertical-align:middle; display:inline-block; font-size:16px;">PTE en x86</div><ul style="font-size:24px;"><li>#PTEs: $2^{20}$. Tamaño de cada PTE: $32$ bit $= 4\text{B}$</li><li>Tamaño de tabla de páginas: $2^{20} \times 2^2 \text{B} = 4\text{MB}$</li><li>Cada proceso requiere $4\text{MB}$ de memoria principal <b>sólo para su tabla de páginas</b>.</li><li>Tabla de páginas se almacena en memoria virtual del Sistema Operativo.</li></ul><div class="fragment"><b>Problema</b>: tablas de páginas grandes &#x1f61e;</div></section><section><blockquote style="background:#B7E1CD;"> <b>¿Cuántos accesos a memoria?</b></blockquote><div>Dirección de tabla de páginas se guarda en PCB, como <b>PageTableBaseRegister</b> (PTBR)</div><div class="fragment" data-fragment-index="2" style="width:55%; vertical-align:middle; display:inline-block;"><pre><code class="hljs lang-c"> VPN = (virtualAddress & VPN_MASK) >> VPN_SHIFT;
 PTEAddress = PageTableBaseRegister + (VPN * sizeof(PTE));
 PTE = ReadMemory(PTEAddress);

 // está en memoria
 if(!PTE.valid)
   raise(SEG_FAULT);
 // verificación de permisos
 else if(PTE.protected)       
   raise(PROTECTION_FAULT);
 // Acceso OK
 else {
   offset = virtualAddress & OFFSET_MASK;
   physicalAddress = (PTE.PFN << PFN_SHIFT) | offset;
   register = ReadMemory(physicalAddress);</code></pre><div><b>Cada acceso a memoria se convierte en DOS accesos</b></div><div><b>Problema</b>: accesos en el doble de tiempo &#x1f61e;</div></div><div class="fragment" data-fragment-index="2" style="width:45%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-8_10.pdf.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section></section><section id="pag_tlb"><h2>Paginación con TLB</h2><section><div>Solución para acelerar acceso a memoria: <i>fully associative caché</i> de direcciones en MMU</div><blockquote class="fragment" data-fragment-index="1" style="background:#F4C7C3;"><b>Translation Look-aside Buffer (TLB)</b> /</blockquote><div style="width:60%; vertical-align:middle; display:inline-block;"><ul class="fragment" data-fragment-index="2" style="font-size:24px;"><li>Si la dirección está en el caché (<i>TLB hit</i>), se responde directamente</li><li>Si la dirección no está en el caché (<i>TLB miss</i>), se lee desde la memoria y se actualiza TLB</li></ul><pre class="fragment" data-fragment-index="4"><code class="hljs lang-c" style="max-height:600px;"> VPN = (virtualAddress & VPN_MASK) >> VPN_SHIFT;
 (Success, TLBEntry) = TLB_Lookup(VPN);
 if(Success) {         //TLB Hit: UN acceso a memoria
   if(!TLBEntry.protected) {
     offset = virtualAddress & OFFSET_MASK;
     physicalAddress = (TLBEntry.PFN << PFN_SHIFT) | offset;
     register = ReadMemory(physicalAddress);
   }
   else raise(PROTECTION_FAULT);
 }
 else {                //TLB Miss: DOS accesos a memoria
   PTEAddress = PageTableBaseRegister + (VPN * sizeof(PTE));
   PTE = ReadMemory(PTEAddress);
   if(!PTE.valid)          raise(SEG_FAULT);
   else if (PTE.protected) raise(PROTECTION_FAULT);
   else {
     TLB_Insert(VPN, PTE);
     Retry();
   }
 }</code></pre></div><div class="fragment" data-fragment-index="3" style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-8_14.pdf.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Efectividad de TLB</h3><div>Ejemplo: espacio virtual de 8 bit, con páginas de 16 B, almacenando arreglo de 10 <code>int</code> (4B).</div><div style="width:75%; vertical-align:middle; display:inline-block;"><ul><li>4 bit para <i>offset</i>. 4 bit para #página. 16 páginas.</li></ul><pre class="fragment" data-fragment-index="1"><code class="hljs lang-c">int sum = 0;
for(i=0; i<10; i++)
  sum += a[i];</code></pre><ul class="fragment" data-fragment-index="2"><li>Considerando sólo el acceso a <code>a</code></li><li>Sin TLB: 10 $\times$ (acceso tabla de páginas, acceso <code>a[i]</code>)</li><ul><li>20 accesos a memoria</li></ul><li class="fragment" data-fragment-index="3">Con TLB: miss, hit, hit, miss, hit, hit, hit, miss, hit, hit</li><ul class="fragment" data-fragment-index="3"><li>10 accesos a <code>a[i]</code>, 3 accesos a tabla de páginas (miss)</li><li>13 accesos a memoria</li></ul></ul><div class="fragment" data-fragment-index="4">7 de 10 accesos ahorrados: $70\%$ TLB <i>Hit Rate</i></div><div class="fragment" data-fragment-index="4" style="font-size:18px;">Con páginas más grandes, el <i>Hit Rate</i> hubiese aumentado</div></div><div style="width:25%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-tlb-effect.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Efectividad de TLB</h3><div>¿Es bueno $70\%$ de TLB <i>Hit Rate</i>?</div><div style="width:75%; vertical-align:middle; display:inline-block;"><pre><code class="hljs lang-c">int sum = 0;
for(i=0; i<10; i++)
  sum += a[i];</code></pre><ul><li>Un acceso a memoria física $\approx 100\text{ns} = 10^{-7}\text{s}$</li><li>Un acceso a TLB $\approx 1\text{ns} = 10^{-9}\text{s}$</li><li>TLB Hit $\approx 101\text{ns}$</li><li>TLB Miss $\approx 201\text{ns}$</li></ul><ul class="fragment"><li>Sin TLB. 20 acc. a memoria. $2000\text{ns} = 2\times 10^{-6}\text{s}$</li><li>Con TLB. 13 acc. a memoria, 10 acc. a TLB. $1310\text{ns} = 1.31 \times 10^{-6}\text{s}$</li><li>Aceleración: $2000/1310 \approx 1.52$ veces más rápido.</li><li>Tiempo promedio de acceso: $201\text{ns} \times 0.3 + 101\text{ns} \times 0.7 = 131\text{ns}$</li></ul><blockquote class="fragment" style="background:#B7E1CD;">TLB Hit Rate reales $\approx 99\%$</blockquote></div><div style="width:25%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-tlb-effect.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Efectividad de TLB</h3><div>TLB Hit Rate reales $\approx 99\%$</div><div><b>¿Por qué funciona?</b></div><div style="width:50%; vertical-align:middle; display:inline-block;"><blockquote style="background:#B7E1CD;">Localidad Espacial</blockquote><pre><code class="hljs lang-c">int sum = 0;
for(i=0; i<1000; i++)
  sum += a[i];</code></pre><div align="left" class="fragment" data-fragment-index="1">Después de acceder a una dirección <code>x</code>, el programa probablemente accederá a direcciones cercanas a <code>x</code></div><ul class="fragment" data-fragment-index="2"><li>Luego de un <i>miss</i>, y guardar un PTE en TLB, vendrán muchos <i>hit</i></li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><blockquote style="background:#B7E1CD;">Localidad Temporal</blockquote><pre><code class="hljs lang-c">int sum = 0;
for(k=0; k<10; k++)
  for(i=0; i<1000; i++)
    sum += a[i];</code></pre><div align="left" class="fragment" data-fragment-index="3">Una dirección <code>x</code> que acaba de ser accedida, probablemente será accedida de nuevo dentro de poco tiempo</div><ul class="fragment" data-fragment-index="4"><li>Una PTE recién guardada, volverá a ser usada pronto</li></ul></div><div class="fragment" data-fragment-index="5"><i>El comportamiento real depende del programa, pero la mayor parte del tiempo los programas manifiestan localidad de referencia (espacial o temporal).</i></div></section><section><h3>Detalles de TLB</h3><div><b>¿Dónde se guardan los datos de un TLB ante un cambio de contexto?</b></div><ul class="fragment" data-fragment-index="1"><li>TLB no se almacena en memoria del S.O. (como la Tabla de Páginas), ni en el PCB</li><li>PTBR se actualiza en cada cambio de contexto</li><li>PTEs de un proceso no sirven al siguiente proceso</li><li>Se puede borrar completamente el TLB (<i>flush</i>), marcando todas los <b>valid bit</b> en 0.</li></ul><img src="../images/figures/02-tlb-entry.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="50%" /><div style="font-size:18px;">TLB Entry de un MIPS R4000</div><ul class="fragment" data-fragment-index="2"><li><code>V</code> indica si la <b>entrada del TLB</b> es válida</li><ul><li style="font-size:20px;">Atención: no es el mismo valid bit de la PTE</li></ul><li><code>ASID</code> indica el <b>Address Space Identifier</b></li><ul><li>Cada proceso tiene su propio <code>ASID</code> (en su PCB)</li><li>Campo <code>ASID</code> permite que coexistan entradas de distintos procesos en el TLB</li></ul></ul></section></section><section id="pag_tlb"><h2>Variantes de paginación</h2><section><div><b>Problema</b>: tablas de páginas muy grandes &#x1f61e;</div><ul class="fragment" data-fragment-index="1"><li>Arquitectura con espacio de direcciones virtuales de 32 bit</li><li>Páginas de $4$KB. $20$ bit para #página, $12$ bit para <i>offset</i></li><li>Tabla de páginas necesita $2^{20}$ PTEs</li><li>Tamaño de cada PTE: $32$ bit $= 4\text{B}$</li><li>Tamaño de tabla de páginas: $2^{20} \times 2^2 \text{B} = 4\text{MB}$</li><li>Con 100 procesos, se gasta $400\text{MB}$ del Sistema Operativo <b>sólo en tablas de páginas</b>.</li></ul><blockquote class="fragment" data-fragment-index="2" style="background:#B7E1CD;">Solución: <i>páginas más grandes</i></blockquote><ul class="fragment" data-fragment-index="3"><li>Con páginas de $1\text{MB}$. $20$ bit para <i>offset</i>, $12$ bit para #página</li><li>Tablas de páginas necesita $2^{12}$ PTEs</li><li>Tamaño de tabla de páginas: $16\text{KB}$ &#x1f389;</li></ul></section><section><h3>Fragmentación Interna</h3><blockquote style="background:#B7E1CD;"><b>Fragmentación Externa</b>. Espacios libres no contiguos.</blockquote><div>Paginación elimina la fragmentación externa (¿por qué?), pero &hellip;</div><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;"><b>Fragmentación Interna</b>. Espacios sobreasignado.</blockquote><div class="fragment" data-fragment-index="2">Si las páginas son de $1\text{MB}$ &hellip;</div><ul class="fragment" data-fragment-index="3"><li>Procesos de $x\text{MB}$, con $x$ entero reciben la cantidad exacta de espacio.</li><li>Un proceso de $16\text{KB}$ recibe $1\text{MB}$ ($1008\text{KB}$ desperdiciados)</li><li>Un proceso de $1025 \text{KB}$ recibe $2\text{MB}$</li></ul><div class="fragment" data-fragment-index="4">Espacio se asigna a los procesos pero no se utiliza</div><br /><div class="fragment" data-fragment-index="4">Paginas más grandes aumentan la fragmentación interna. &#x1f61e;</div><br /><div class="fragment" data-fragment-index="5">¿De qué tamaño son las páginas de su sistema? (Tip: <code>getconf PAGE_SIZE</code>)</div></section><section><h3>Segmentos paginados</h3><div>Procesos no suelen ocupar todas sus páginas</div><div style="width:70%; vertical-align:middle; display:inline-block;"><div>Espacio virtual con 16 páginas.</div><ul><li>Proceso utiliza efectivamente: 4 páginas</li><li>12 entradas vacías ($75\%$) en tabla de páginas</li></ul><img class="fragment" data-fragment-index="1" src="../images/figures/02-hybrid-va.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /><br /><div class="fragment" data-fragment-index="2"><b>Idea</b>: una tabla de páginas por segmento</div><ul class="fragment" data-fragment-index="3"><li>Tablas de páginas más pequeña &#x1f603;</li><li><code>base</code> (direcc. de tabla de páginas)</li><li><code>limit</code> (#paginas)</li><li>Vuelve la fragmentación externa &#x1f61f;</li></ul></div><div style="width:30%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-hybrid.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Tablas de páginas multinivel</h3><div>En lugar de segmentar, mejor <b>paginar</b> la tabla de páginas</div><div><img src="../images/figures/02-multilevel-va.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="30%" /></div><div style="width:60%; vertical-align:middle; display:inline-block;"><ul class="fragment" data-fragment-index="2"><li>Dirección virtual de 14-bit, páginas de $64\text{B}$.</li><li>Esquema de 1 nivel: 256 PTEs. </li><ul style="font-size:24px;"><li>Memoria: $256 \times 4\text{B} = 1    \text{KB}$</li></ul><li>Esquema de 2 niveles: 16 PTEs en tabla principal, 16 PTEs en 16 tablas de 2do nivel</li><ul style="font-size:24px;"><li>Memoria: Al menos tabla principal + 1 tabla secundaria</li><li>Memoria: $16 \times 4\text{B} + 16 \times 4\text{B} = 128{B}$</li></ul></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-multilevel-1.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Tablas de páginas multinivel</h3><div>Esquema se puede extender a más niveles</div><div><img src="../images/figures/02-multilevel-2.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="40%" /></div><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>En memoria se necesita la tabla de páginas del primer nivel (completa), y una tabla de cada nivel para poder resolver una dirección física</li><li>Cada división puede tener distintos tamaños</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-multilevel-3.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="80%" /></div></section><section><h3>Tablas de páginas invertidas</h3><div>En lugar de guardar una tabla por proceso, mantener una tabla <b>única para todo el sistema</b></div><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Indice es el <i>frame</i>. Una PTE por <i>frame</i>.</li><li>Clave de búsqueda es $\langle$ pid, #page $\rangle$</li><li>Consume menos memoria &#x1f603;</li><li>Pero búsqueda es lenta (secuencial) &#x1f61e;</li><li>Alternativa: usar <i>hashing</i></li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-8_20.pdf.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div><div>PowerPC usaba este esquema</div></section></section><section id="page_replace"><h2>Reemplazo de páginas</h2><section><div><b>Supuesto a eliminar</b>: todo el espacio de direcciones cabe en memoria física</div><div>Procesos pueden tener parte de su memoria no cargada aún (en disco), o en <i>swap</i> (en disco).</div><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;">Desafío: usar efectivamente el disco (grande, pero lento) para proveer la ilusión que <b>todo</b> el espacio virtual está en memoria</blockquote><br /><div class="fragment" data-fragment-index="2">Procesos deben seguir creyendo que pueden acceder a todo el rango de direcciones virtuales</div><ul class="fragment" data-fragment-index="2"><li>¿Por qué? Es más fácil para el proceso (separa la <i>ilusión</i> de la realidad)</li><li>Sistema Operativo se encarga de cargar las páginas <i>on-demand</i></li></ul><br /><br /><div class="fragment" data-fragment-index="3"> Si no caben más páginas en memoria física, alguna debe salir para hacer más espacio</div><blockquote class="fragment" data-fragment-index="3" style="background:#B7E1CD;">¿Qué página eliminar?, y ¿a dónde moverla?</blockquote></section><section><h3>Swap space</h3><blockquote style="background:#B7E1CD;">¿A dónde mover las páginas de memoria?</blockquote><div class="fragment" data-fragment-index="1">Páginas que van a ser borradas de memoria van a <i>espacio de <b>swap</b></i></div><ul class="fragment" data-fragment-index="1"><li>Representan parte del espacio de memoria de un proceso <b>en ejecución</b></li><li>Tabla de páginas utiliza <b>present bit</b> para saber si la página está en un <i>frame</i> o no</li></ul><blockquote class="fragment" data-fragment-index="2" style="background:#B7E1CD;">Si la página no está presente, se genera un <b>page fault</b></blockquote><div class="fragment" data-fragment-index="2"><b>Page fault</b> activa el mecanismo de recuperación de una página desde disco a memoria física</div><ul class="fragment" data-fragment-index="2"><li>Sistema Operativo atiende el <i>page fault</i></li><li>Cuando el <i>page fault</i> ha sido resuelto, el proceso puede continuar</li></ul></section><section><h3>Page Fault</h3><div>Ante un <i>page fault</i>, el sistema operativo va a buscar la página</div><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="font-size:26px;">Algoritmo para paginación con TLB, y <i>page faults</i></div><pre><code class="hljs lang-c" style="max-height:600px;"> VPN = (virtualAddress & VPN_MASK) >> VPN_SHIFT;
 (Success, TLBEntry) = TLB_Lookup(VPN);
 if(Success) {         //TLB Hit
   if(!TLBEntry.protected()) {
     offset = virtualAddress & OFFSET_MASK;
     physicalAddress = (TLBEntry.PFN << PFN_SHIFT) | offset;
     register = ReadMemory(physicalAddress);
   }
   else raise(PROTECTION_FAULT);
 }
 else {                //TLB Miss
   PTEAddress = PageTableBaseRegister + (VPN * sizeof(PTE));
   PTE = ReadMemory(PTEAddress);    // lectura tabla de paginas
   if(!PTE.valid)          raise(SEG_FAULT);
   else if (PTE.protected) raise(PROTECTION_FAULT);
   else if (!PTE.present)  raise(PAGE_FAULT);
   else {                  // pagina en memoria
     TLB_Insert(VPN, PTE);
     Retry();
   }
 }</code></pre></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-9_01.pdf.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Page Fault</h3><div>Mecanismo de rutina <i>page-fault handler</i></div><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="font-size:26px;">Algoritmo para manejar un <i>page fault</i></div><pre><code class="hljs lang-c" style="max-height:600px;"> PFN = FindFreePhysicalPage();   // busca frame libre
 if(PFN == -1)                   '// no había frame libre :'(
   PFN = ReplacePage();          // rutina de reemplazo de página

 // Copia desde el disco a la memoria. Proceso queda "waiting on I/O"
 DiskRead(PTE.DiskAddress, PFN);

 // Actualiza tabla de páginas
 PTE.present = TRUE;
 PTE.PFN = PFN;

 // Vuelve a ejecutar la instrucción que generó el PAGE_FAULT 
 Retry(); </code></pre></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-9_06.pdf.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><blockquote style="background:#B7E1CD;">¿Qué página reemplazar?</blockquote><div>La ocurrencia de un <i>page-fault</i> es algo malo (significa acceder al disco)</div><br /><br /><div>Cualquier algoritmo de decisión debe intentar minimizar la ocurrencia de <i>page-faults</i></div><br /><br /><div>Ejemplo: direcciones virtuales de 16 bit, páginas de 4KB</div><ul><li>Ocurre un <i>page-fault</i> para acceder a la dirección $0x6300$ (página $6$)</li><li>Se escoge la página $9$ y se hace <i>swap</i></li><li>Proceso continúa y solicita dirección $0x9204$</li><li>Ocurre otro <i>page-fault</i></li><li>No fue tan buena idea haber sacado la página $9$.</li></ul></section><section><h3>MIN: Reemplazo óptimo</h3><div>Planteado por Laszlo A. Belady, 1966</div><blockquote style="background:#B7E1CD;">Elegir la que será usada lo más lejos posible en el futuro</blockquote><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;">Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso</div><div style="font-size:32px;">Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1</div><table style="font-size:20px;"><tr><td>Página</td><td>Hit/Miss</td><td>Reemplazar</td><td>Páginas en mem.</td></tr><tr><td>0</td><td>Miss</td><td></td><td>0</td></tr><tr><td>1</td><td>Miss</td><td></td><td>0, 1</td></tr><tr><td>2</td><td>Miss</td><td></td><td>0, 1, 2</td></tr><tr><td>0</td><td>Hit</td><td></td><td>0, 1, 2</td></tr><tr><td>1</td><td>Hit</td><td></td><td>0, 1, 2</td></tr><tr><td>3</td><td>Miss</td><td>2</td><td>0, 1, 3</td></tr><tr><td>0</td><td>Hit</td><td></td><td>0, 1, 3</td></tr><tr><td>3</td><td>Hit</td><td></td><td>0, 1, 3</td></tr><tr><td>1</td><td>Hit</td><td></td><td>0, 1, 3</td></tr><tr><td>2</td><td>Miss</td><td>3</td><td>0, 1, 2</td></tr><tr><td>1</td><td>Hit</td><td></td><td>0, 1, 2</td></tr></table></div><div style="width:40%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;">Tasa de hits (<i>Hit Rate</i>)</div><div style="font-size:32px;">$\text{Hit Rate} = \frac{6}{6+5} = 0.545$</div><div style="font-size:32px;">Si ignoramos el primer <i>miss</i> de cada página (<i>cold start</i>)</div><div style="font-size:32px;">$\text{Hit Rate} = \frac{6}{6+2} = 0.75$</div><br /><br /><div>El mejor algoritmo &#x1f603;</div><div>Pero no podemos conocer el futuro &#x1f61e;</div></div></section><section><h3>FIFO: First In First Out</h3><div>Muy simple de implementar </div><blockquote style="background:#B7E1CD;">Elegir la página que lleva más tiempo en memoria</blockquote><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;">Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso</div><div style="font-size:32px;">Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1</div><table style="font-size:20px;"><tr><td>Página</td><td>Hit/Miss</td><td>Reemplazar</td><td>Páginas en mem.</td></tr><tr><td>0</td><td>Miss</td><td></td><td>Queue: 0</td></tr><tr><td>1</td><td>Miss</td><td></td><td>Queue: 0, 1</td></tr><tr><td>2</td><td>Miss</td><td></td><td>Queue: 0, 1, 2</td></tr><tr><td>0</td><td>Hit</td><td></td><td>Queue: 0, 1, 2</td></tr><tr><td>1</td><td>Hit</td><td></td><td>Queue: 0, 1, 2</td></tr><tr><td>3</td><td>Miss</td><td>0</td><td>Queue: 1, 2, 3</td></tr><tr><td>0</td><td>Miss</td><td>1</td><td>Queue: 2, 3, 0</td></tr><tr><td>3</td><td>Hit</td><td></td><td>Queue: 2, 3, 0</td></tr><tr><td>1</td><td>Miss</td><td>2</td><td>Queue: 3, 0, 1</td></tr><tr><td>2</td><td>Miss</td><td>3</td><td>Queue: 0, 1, 2</td></tr><tr><td>1</td><td>Hit</td><td></td><td>Queue: 0, 1, 2</td></tr></table></div><div style="width:40%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;"><i>Hit Rate</i></div><div style="font-size:32px;">$\text{Hit Rate} = \frac{4}{4+7} = 0.364$</div><div style="font-size:32px;">Sin <i>cold start</i></div><div style="font-size:32px;">$\text{Hit Rate} = \frac{4}{4+4} = 0.5$</div><br /><br /><div>Más malo que MIN &#x1f61e;</div><div>Si hay más <i>frames</i> disponibles, se debería comportar mejor (¿o no?)</div></div></section><section><h3>RANDOM</h3><div>Simple de implementar </div><blockquote style="background:#B7E1CD;">Elegir una página aleatoria</blockquote><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;">Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso</div><div style="font-size:32px;">Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1</div><img src="../images/figures/02-random.png" style="background:none; border:none; box-shadow:none;" width="60%" /><div style="font-size:32px;">10000 ejecuciones</div></div><div style="width:40%; vertical-align:middle; display:inline-block;"><ul><li>MIN <i>hits</i>: 6</li><li>FIFO <i>hits</i>: 4</li></ul><br /><br /><div>FIFO y RANDOM no aprovechan la localidad de referencia</div><br /><br /><div>Podrían eliminar páginas que van a usarse en el corto plazo.</div></div></section><section><h3>LRU: Least Recently Used</h3><div>Una página que se usó recientemente, probablemente pronto será usada otra vez</div><blockquote style="background:#B7E1CD;">Elegir la página que lleva más tiempo sin usarse</blockquote><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;">Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso</div><div style="font-size:32px;">Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1</div><table style="font-size:20px;"><tr><td>Página</td><td>Hit/Miss</td><td>Reemplazar</td><td>Páginas en mem.</td></tr><tr><td>0</td><td>Miss</td><td></td><td>LRU: 0</td></tr><tr><td>1</td><td>Miss</td><td></td><td>LRU: 0, 1</td></tr><tr><td>2</td><td>Miss</td><td></td><td>LRU: 0, 1, 2</td></tr><tr><td>0</td><td>Hit</td><td></td><td>LRU: 1, 2, 0</td></tr><tr><td>1</td><td>Hit</td><td></td><td>LRU: 2, 0, 1</td></tr><tr><td>3</td><td>Miss</td><td>2</td><td>LRU: 0, 1, 3</td></tr><tr><td>0</td><td>Hit</td><td></td><td>LRU: 1, 3, 0</td></tr><tr><td>3</td><td>Hit</td><td></td><td>LRU: 1, 0, 3</td></tr><tr><td>1</td><td>Hit</td><td></td><td>LRU: 0, 3, 1</td></tr><tr><td>2</td><td>Miss</td><td>0</td><td>LRU: 3, 1, 2</td></tr><tr><td>1</td><td>Hit</td><td></td><td>LRU: 3, 2, 1</td></tr></table></div><div style="width:40%; vertical-align:middle; display:inline-block;"><div style="font-size:32px;"><i>Hit Rate</i></div><div style="font-size:32px;">$\text{Hit Rate} = \frac{6}{6+5} = 0.545$</div><div style="font-size:32px;">Sin <i>cold start</i></div><div style="font-size:32px;">$\text{Hit Rate} = \frac{6}{6+2} = 0.75$</div><br /><br /><ul><li>MIN: 1 <i>miss</i>, Hit Rate $0.75$</li><li>FIFO: 3 <i>misses</i>, Hit Rate $0.571$</li><li>Similar a MIN &#x1f603;</li><li>Implementable &#x1f603;</li><li>¿Eficientemente? &#x1f914;</li></ul></div></section><section><h3>Workload sin localidad</h3><div>Algoritmos de reemplazo se comparan ejecutándolos bajo una secuencia de accesos a páginas (<i>workload</i>), y distinta cantidad de <i>frames</i> disponibles.</div><div style="width:65%; vertical-align:middle; display:inline-block;"><div>100 páginas. Secuencia de 10000 accesos sin localidad.</div><br /><br /><ul><li>Sin localidad todas las políticas que podemos implementar se comportan igual</li><li>Con suficientes <i>frames</i> disponibles se llega a <i>Hit Rate</i> 1.</li><li>Patrón poco común (pero posible)</li></ul></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-replacement-nolocality.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="90%" /><ul style="font-size:18px;"><li>La cantidad de <i>frames</i> disponibles es como una cantidad de bloques de caché en memoria física</li><li>OPT $\equiv$ MIN</li></ul></div></section><section><h3>Workload 80-20</h3><div>100 páginas. Secuencia con 80% de localidad en 10000 accesos.</div><div style="width:65%; vertical-align:middle; display:inline-block;"><ul><li>80% de los 10000 accesos se hacen a un 20% de páginas (<i>hot pages</i>)</li><li>20% de los 10000 accesos se hacen al 80% de páginas restantes (<i>cold pages</i>)</li></ul><br /><br /><ul><li>LRU mejor que FIFO y RANDOM</li><li>Patrón más común</li></ul></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-replacement-8020.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="90%" /><ul style="font-size:18px;"><li>La cantidad de <i>frames</i> disponibles es como una cantidad de bloques de caché en memoria física</li><li>OPT $\equiv$ MIN</li></ul></div></section><section><h3>Workload con loop secuencial</h3><div>100 páginas. Acceso secuencial a 50 páginas (0, 1, &hellip;, 49). Se repite hasta completar 10000 accesos.</div><div style="width:65%; vertical-align:middle; display:inline-block;"><ul><li>FIFO y LRU eliminan las páginas más "antiguas"</li><li>RANDOM se comporta mejor</li></ul><br /><br /><ul><li>Peor caso para FIFO y LRU</li><li>Patrón común en muchas aplicaciones</li><li>Tamaño del conjunto de páginas usadas es crítico</li></ul></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-replacement-loop.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="90%" /><ul style="font-size:18px;"><li>La cantidad de <i>frames</i> disponibles es como una cantidad de bloques de caché en memoria física</li><li>OPT $\equiv$ MIN</li></ul></div></section><section><h3>Implementando LRU</h3><div>¿Fácil de implementar?</div><ul><li>Estructura para FIFO se actualiza en cada <i>miss</i></li><li>Estructura para LRU se actualiza en <b>cada acceso</b> &#x1f62e;</li></ul><br /><br /><div class="fragment" data-fragment-index="1"><i>Algunas alternativas para implementar LRU</i></div><ul class="fragment" data-fragment-index="2"><li>Mantener cola ordenada en cada acceso a memoria. Caro.</li><li>Agregar <i>timestamp</i> en cada acceso. Puede ser por <i>hardware</i> (más barato).</li><ul><li>Al momento de reemplazar se elige la que tiene menor <i>timestamp</i></li><li>Requiere comparar <i>todas</i> las páginas candidatas. Caro.</li></ul></ul></section><section><h3>Aproximando LRU</h3><div>LRU se puede <i>aproximar</i> con ayuda del <i>hardware</i></div><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;"><b>Algoritmo del reloj (clock)</b></blockquote><div class="fragment" data-fragment-index="1" style="font-size:18px;">Casi igual que <b>algoritmo de segunda oportunidad</b></div><div class="fragment" data-fragment-index="2"> Aproximación basada en <b>reference bit</b> (1 si la página ha sido usada)</div><div class="fragment" data-fragment-index="3" style="width:60%; vertical-align:middle; display:inline-block;"><ul><li>Algoritmo apunta a una página (cualquiera)</li><li>Al momento de elegir, se mira <b>reference bit</b></li><ul><li>Si <b>reference bit</b>$=$1, se cambia a 0 y pasa a la siguiente página</li><li>Si <b>reference bit</b>$=$0, se elige esta página</li></ul></ul><br /><br /><div>Aproxima LRU bastante bien, y es eficiente</div></div><div class="fragment" data-fragment-index="3" style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-clock.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Aproximando LRU</h3><div>Enfoque de múltiples <b>reference bit</b></div><blockquote style="background:#B7E1CD;">Algoritmo de <b>aging</b></blockquote><div class="fragment" data-fragment-index="1" style="width:50%; vertical-align:middle; display:inline-block;"><div>Contadores por cada página</div><ul><li>Contadores se actualizan por <i>hardware</i> a intervalos regulares</li><li>En cada <i>tick</i>, los <i>reference bit</i> se copian a cada contador (left shift), y se borran</li><li>Secuencia de bit sirve como historia</li><li>Página con menor contador es la menos usada</li></ul></div><div class="fragment" data-fragment-index="1" style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/02-aging.png" style="background:none; border:none; box-shadow:none; vertical-align:middle;" width="100%" /></div></section><section><h3>Aproximando LRU</h3><div>Usando los <b>dirty bit</b> (1 si la página ha sido modificada), se pueden priorizar mejor las páginas para el algoritmo del reloj.</div><br /><br /><table><tr><td>Reference</td><td>Dirty</td><td></td></tr><tr><td>0</td><td>0</td><td>No usada recientemente ni modificada. Buena candidata.</td></tr><tr><td>0</td><td>1</td><td>No usada recientemente, pero modificada.</td></tr><tr><td>1</td><td>0</td><td>Usada recientemente, pero no modificada.</td></tr><tr><td>1</td><td>1</td><td>Usada recientemente y modificada.</td></tr></table></section></section><section id="reemp"><h2>Working Set y Thrashing</h2><section id="reemp13"><div>El modelo de <b>working set</b> intenta determinar si un proceso tiene una cantidad apropiada de <i>frames</i></div><blockquote class="fragment" data-fragment-index="1" style="background:#B7E1CD;"><b>Working Set</b>, $w_{\Delta}(t)$: conjunto de páginas utilizadas por un proceso en los últimos $\Delta$ acceso a memoria.</blockquote><div class="fragment" data-fragment-index="1"><img src="../images/figures/02-9_20.pdf.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><ul class="fragment" data-fragment-index="2"><li>Medida de la demanda efectiva por <i>frames</i> de un proceso.</li><li>Si no se le puede asignar $|w_{\Delta}(t)|$ <i>frames</i> no conviene tenerlo en ejecución</li><li>Si la suma de los <i>working set</i> de todos los procesos es mayor a la cantidad de <i>frames</i> en el sistema, habrá <i>thrashing</i></li></ul><div class="fragment" data-fragment-index="3">El <i>working set</i> es usado por el <i>medium-term scheduler</i>. /</div><ul class="fragment" data-fragment-index="3"><li>Se puede implementar usando los <b>reference bit</b></li></ul></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        //mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        //Migrated. Check here: https://www.mathjax.org/cdn-shutting-down/
        mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>