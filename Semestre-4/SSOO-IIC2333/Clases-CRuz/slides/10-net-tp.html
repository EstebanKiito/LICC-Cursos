<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Capa de Transporte</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>Capa de Transporte</h1><p>Semestre 2022-1<br/>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación<br/>Pontificia Universidad Católica de Chile</p></section><section><h2>Protocolos de Transporte</h2><section><blockquote style="background:#B7E1CD;"><b>Objetivo</b>: Conseguir que un mensaje llegue desde <i>emisor</i> a <i>receptor</i></blockquote><div><img src="../images/figures/10-transporte.png" style="background:none; border:none; box-shadow:none;" width="35%" /></div></section><section><ul><li><b>Emisor</b>. Recibe un mensaje de capa de aplicación, lo divide en segmentos, y solicita a la capa de red que envíe los segmentos al receptor. Routers no examinan <i>headers</i> de transporte.</li><li><b>Receptor</b>. Recibe segmentos, los ensambla para formar el mensaje, y lo entrega a la capa de aplicación.</li></ul><br /><br /><div style="text-align:left;">Dos protocolos representativos de medios de transporte:</div><ul><li><b>TCP</b>: Entrega confiable y ordenada. Control de flujo. Establecimiento de conexión.</li><li><b>UDP</b>: Entrega no confiable y desordenada. Mejor esfuerzo.</li></ul></section><section><h3>Segmentos</h3><div style="width:65%; vertical-align:middle; display:inline-block;"><div>Mensaje se divide en segmentos.</div><br /><div>Segmentos se transmiten en paquetes IP.</div><br /><div>¿Cómo identificar mensajes a distintos procesos?</div><ul><li><b>Puerto</b> permite identificar procesos dentro del nodo emisor o del nodo receptor.</li><li><b>Puerto</b> permite <b>multiplexar</b> mensajes</li></ul></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-segmento.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Multiplexión</h3><div tyle="text-align:left;">Proceso envían mensajes a través de <b>sockets</b> del Sistema Operativo</div><br /><ul><li>Cada <b>socket</b> se crea con un número de puerto específico</li><li>Cada <i>host</i> puede tener múltiples <b>sockets</b> abiertos</li></ul><div><img src="../images/figures/10-sockets.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Demultiplexión sin conexión</h3><div style="text-align:left;">Segmento UDP identificado por: $\langle$IP destino, puerto destino$\rangle$</div><ul><li>Receptor observa el puerto de destino</li><li>Pasa el segmento al proceso asociado al puerto de destino</li></ul><div><img src="../images/figures/10-udpports.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Demultiplexión con conexión</h3><div>Segmento TCP identificado por: $\langle$ IP origen, puerto origen, IP destino, puerto destino$\rangle$</div><div>Servidores pueden gestionar múltiples conexiones TCP</div><ul><li>Se pueden asociar distintos sockets a distintos clientes</li></ul><div><img src="../images/figures/10-tcpports.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section></section><section><h2>UDP</h2><section><h3>User Datagram Protocol</h3><div style="width:70%; vertical-align:middle; display:inline-block;"><ul><li>Servicio de "mejor esfuerzo" (best-effort). </li><li>Segmentos pueden perderse.</li><li>Segmentos pueden llegar en distinto orden.</li></ul><br /><br /><div>Servicio <b>no orientado a conexión</b> (<i>connection-less</i>)</div><ul><li>No se establece conexión previa</li><li>No mantiene estado de conexión</li><li>Cada segmento se gestiona de manera independiente</li></ul><br /><br /><div>Segmento UDP solo tiene 8 byte de <i>overhead</i></div></div><div style="width:30%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-udpsegment.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>UDP Segment</h3><div style="width:70%; vertical-align:middle; display:inline-block;"><div>¿Por qué mejor UDP?</div><ul><li>Aplicación puede controlar directamente el envío</li><li>No hay demora en establecer conexión</li><ul style="font-size:24px;"><li>Menor <i>overhead</i> de tiempo</li></ul><li>No se reservan recursos</li><li>Menor <i>overhead</i> de espacio: 8 byte</li><ul style="font-size:24px;"><li>TCP tiene 20 byte</li></ul></ul></div><div style="width:30%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-udp-joke.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section></section><section><h2>Reliable Data Transfer</h2><section><div style="text-align:left;"><b>Desafío</b>: Proveer transferencia confiable (<i>reliable</i>) sobre un medio no confiable (<i>unreliable</i>)</div><div><img src="../images/figures/10-rdt.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div></section><section><div><b>Versión 1.0</b>. Canal de transmisión confiable.</div><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Supuesto  fuerte, pero simple.</div><br /><div><b>Sender</b></div><ul style="font-size:28px;"><li>Al recibir solicitud de envío, crea un paquete y envía</li></ul><br /><div><b>Receiver</b></div><ul style="font-size:28px;"><li>Al recibir paquete, extrae mensaje y lo pasa a aplicación</li></ul><br /><br /><div class="fragment"><b>Problema</b>: Los paquetes pueden llegar con errores</div></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-rdt-v1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div><b>Versión 2.0</b>. Protocolo ARQ (Automatic Repeat reQuest)</div><ul style="font-size:28px;"><li>Detección de errores. Envía <i>checksums</i>. </li><li>Paquetes de <i>feedback</i>. ACK (<i>acknowledgment</i>) y NAK (<i>negative ACK</i>)</li><li>Retransmisiones.</li></ul><div><img src="../images/figures/10-rdt-v2-send.png" style="background:none; border:none; box-shadow:none;" width="60%" /><img src="../images/figures/10-rdt-v2-recv.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div><div class="fragment">¿ACK o NAK con errores? El <i>sender</i> no sabe si el <i>receiver</i> recibió correctamente o no.</div><ul style="font-size:28px;"><li>¿Retransmitir al recibir un ACK o NAK corrupto? Pueden llegar duplicados.</li></ul></section><section><div><b>Versión 2.1</b>. Agregar un <b>sequence number</b>. Por ahora, 1-bit.</div><div><img src="../images/figures/10-rdt-v21-send.png" style="background:none; border:none; box-shadow:none;" width="50%" /><img src="../images/figures/10-rdt-v21-recv.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><div><b>Versión 2.2</b>. Podemos eliminar los NAK. Cada ACK adjunta el <b>sequence number</b></div><div><img src="../images/figures/10-rdt-v22-send.png" style="background:none; border:none; box-shadow:none;" width="50%" /><img src="../images/figures/10-rdt-v22-recv.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div class="fragment">¿Y si se pierden paquetes?</div></section><section><div><b>Versión 3.0</b>. <b>Timeout</b> para retransmisión en el <i>sender</i>.</div><div><img src="../images/figures/10-rdt-v3-send.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><div a="">Funcionamiento sin pérdida. (b) Con un paquete perdido</div><div><img src="../images/figures/10-rdt-sequence-a.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div></section><section><div c="">Funcionamiento con ACK perdido. (d) Con un <i>timeout</i> prematuro</div><div><img src="../images/figures/10-rdt-sequence-b.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div></section><section><div style="text-align:left;">Protocolos mandan de un paquete a la vez (<i>stop and wait</i>). Se envían varios paquetes simultáneos en modo <i>pipelined</i>.</div><div><img src="../images/figures/10-rdt-pipeline.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><div style="text-align:left;">Se necesitan más características.</div><ul><li>Números de secuencia deben ser incrementales</li><li>Tanto emisor como receptor necesitan <i>buffers</i></li><li>Dos enfoques para manejar paquetes: <b>Go-Back-N</b>, <b>Selective Repeat</b></li></ul></section><section><h3>Go-back-N</h3><div style="width:70%; vertical-align:middle; display:inline-block;"><div><img src="../images/figures/10-rdt-gbn.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div><ul><li>Emisor puede mantener hasta $N$ paquetes sin ACK</li><li>Receptor envía ACK por el último paquete recibido correctamente</li><li>Emisor usa <i>timer</i> para paquete más antiguo sin ACK</li><ul style="font-size:28px;"><li>Si el <i>timer</i> expira, se retransmite todo el grupo de paquetes sin ACK</li><li><code>base</code> es el paquete más antiguo que aún no tiene ACK</li><li><code>nextseqnum</code> es el próximo número de secuencia a usar</li><li><code>N</code> es un <i>window size</i>. También se conoce como <i>sliding window protocol</i></li></ul><li>Ejemplo con <code>N=4</code></li></ul></div><div style="width:30%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-rdt-gbn-2.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Selective Repeat</h3><div style="width:60%; vertical-align:middle; display:inline-block;"><div><img src="../images/figures/10-rdt-sr.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div><ul style="font-size:28px;"><li>Emisor puede mantener hasta $N$ paquetes sin ACK</li><li>Receptor envía ACK para cada paquete individual</li><li>Emisor usa <i>timer</i> para paquete más antiguo sin ACK</li><ul style="font-size:24px;"><li>Si el <i>timer</i> expira, se retransmite <b>solo</b> paquetes sin ACK</li></ul></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-rdt-sr-2.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section></section><section><h2>TCP</h2><section><h3>Transport Control Protocol</h3><div style="width:60%; vertical-align:middle; display:inline-block;"><ul><li>Protocolo de transmisión fiable</li><li>Transmisión encadenanada <i>chained</i></li><li>Control de flujo a través del tamaño de la ventana</li><li>Buffer en emisor y en receptor</li><li>Orientado a conexión</li><ul style="font-size:24px;"><li>Protocolo de establecimiento de conexión (<i>handshake</i>) antes de enviar paquetes de datos</li></ul></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-segment.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div style="width:60%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-segment-div.png" style="background:none; border:none; box-shadow:none;" width="80%" /><ul><li>Tamaño máximo de segmento: <b>MSS</b>, <i>Maximum Segment Size</i></li><li>Números de secuencia además cuentan bytes en la secuencia</li><li>ACK contienen el <i>sequence number</i> del siguiente byte que se espera. <b>Cumulative ACKs.</b></li><li>Mensaje de respuesta funciona también como ACK. <b>Piggybacked ACK</b></li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-seq.png" style="background:none; border:none; box-shadow:none;" width="100%" /><div>Ejemplo: TELNET</div></div></section><section><div>Algoritmo de transmisión fiable de TCP</div><div style="width:55%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-sr-a.png" style="background:none; border:none; box-shadow:none;" width="80%" /><ul><li><code>SendBase</code> es la base de la ventana</li><li><code>NextSeqNum</code> se actualiza al crear un segmento nuevo para enviar</li><li>Al expirar el <i>timer</i> se retransmite el segmento con menor <i>sequence number</i>.</li><ul style="font-size:24px;"><li>El paquete enviado, o el ACK pueden haberse perdido</li></ul><li>Si llega un ACK con valor mayor a <code>SendBase</code>, se actualiza <code>SendBase</code></li><ul style="font-size:24px;"><li>Esto significa que ya se han recibido los paquetes con valor menor a <code>SendBase</code></li><li>Puede haberse perdido el ACK de los paquetes anteriores</li><li>Este es el funcionamiento del <b>cumulative ACK</b></li></ul></ul></div><div style="width:45%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-alg.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div>Caso: ACK perdido y retransmisión</div><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Si el ACK se pierde, se produce <i>timeout</i></div><ul style="font-size:24px;"><li><i>A</i> reenvía el paquete más antiguo sin ACK (Seq=92)</li><li><i>A</i> reinicia el <i>timer</i></li><li><i>B</i> recibe Seq=92 duplicado. Lo descarta, pero reenvía ACK</li></ul><br /><br /><img src="../images/figures/10-tcp-alg-case2.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-caso1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div>Caso: <i>Timeout</i> prematuro</div><div style="width:60%; vertical-align:middle; display:inline-block;"><div><i>Timeout</i> ocurre antes que llegue el ACK</div><ul style="font-size:24px;"><li><i>A</i> reenvía el paquete más antiguo sin ACK (Seq=92), y reinicia <i>timer</i> (Seq=92)</li><li><i>A</i> recibe ACK y reinicia <i>timer</i>, por Seq=100</li><li><i>A</i> NO reenvía Seq=100, ya que su ACK llega antes del <i>timeout</i></li><li><i>B</i> recibe Seq=92 duplicado. Lo descarta, pero envía (cumulative) ACK</li></ul><br /><img src="../images/figures/10-tcp-alg-case1-2-3.png" style="background:none; border:none; box-shadow:none;" width="70%" /></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-caso2.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div>Caso: Cumulative ACK evita retransmisión</div><div style="width:60%; vertical-align:middle; display:inline-block;"><div>ACK por Seq=92 se pierde</div><ul style="font-size:24px;"><li>El ACK=120 (ACK de Seq=100) llega antes del <i>timeout</i> de Seq=92</li><li>Cumulative ACK (ACK=120) indica que se ha recibido el Seq=92 y el Seq=100</li><li><i>A</i> NO reenvía Seq=92</li><li><i>A</i> incrementa <code>SendBase</code></li></ul><br /><img src="../images/figures/10-tcp-alg-case3.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-caso3.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Retransmisión rápida</h3><div style="width:65%; vertical-align:middle; display:inline-block;"><ul><li><i>Timeout</i>s pueden tomar mucho tiempo</li><li>Retransmisión rápida envía proactivamente segmentos probablemente perdidos, antes que ocurra un timeout</li></ul><img src="../images/figures/10-tcp-alg-case4.png" style="background:none; border:none; box-shadow:none;" width="70%" /></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/10-tcp-fr.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>TCP Handshake Protocol</h3><div><b>Establecimiento de conexión TCP</b></div><br /><ul><li>Paso 1. Cliente envía segmento <code>SYN</code> al servidor</li><ul style="font-size:28px;"><li>Incluye número de secuencia inicial (de cliente)</li></ul><li>Paso 2. Servidor recibe <code>SYN</code>, y responde con <code>SYN ACK</code></li><ul style="font-size:28px;"><li>Servidor asigna buffer</li><li>Servidor establece número de secuencia inicial (de servidor)</li></ul><li>Paso 3. Cliente recibe <code>SYN ACK</code>, y responde con <code>ACK</code></li><ul style="font-size:28px;"><li>Este paquete ya puede contener datos</li></ul></ul></section><section><div><img src="../images/figures/10-tcp-hs1.png" style="background:none; border:none; box-shadow:none;" width="50%" /><img src="../images/figures/10-tcp-hs2.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><div>Cliente y servidor</div><div><img src="../images/figures/10-tcp-hs3.png" style="background:none; border:none; box-shadow:none;" width="50%" /><img src="../images/figures/10-tcp-hs4.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><h3>TCP Joke</h3><img src="../images/figures/10-tcp-joke.png" style="background:none; border:none; box-shadow:none;" width="60%" /></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        //mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        //Migrated. Check here: https://www.mathjax.org/cdn-shutting-down/
        mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>