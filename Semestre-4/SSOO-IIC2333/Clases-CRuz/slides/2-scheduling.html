<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Scheduling</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>Scheduling</h1><p>Semestre 2022-1<br/>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación<br/>Pontificia Universidad Católica de Chile</p></section><section><h2>Scheduling</h2></section><section><h2>Scheduling</h2><section><p>Planificación</p><p class="fragment">En todos los problemas en que los recursos no son suficientes es necesario revisar cómo se distribuyen, <span class="fragment"> y aunque sean <a href="https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel">infinitos</a> hay que administrarlos para evitar conflictos.</span></p><!--Hilbert's paradox--><!--https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel--><ul><li class="fragment">Préstamo de libros en la biblioteca</li><li class="fragment">Asignación de alumnos, cursos y salas</li><li class="fragment">Tareas y empleados</li></ul><p class="fragment">Y dentro de lo que nos concierne,</p><ul><li class="fragment">Asignación de procesos a la CPU</li><li class="fragment">Uso de I/O por los procesos</li><ul><li class="fragment">Disco</li><li class="fragment">Memoria</li><li class="fragment">Red</li><li class="fragment">'/dev/*' audio, gpu,&hellip;</li><!--QoS--></ul></ul></section></section><section id="cpuSched"><h2>CPU-Scheduling</h2></section><section id="cpuSched-init_"><h2>CPU-Scheduling</h2><section id="cpuSched-init"><p><strong>¡Multiprogramación y Time-sharing (<em>multitasking</em>)!</strong></p><p class="fragment">Objetivo de tener multiprogramación:</p><ul class="fragment"><li><strong>Maximizar utilización de (una) CPU</strong></li></ul><p class="fragment">Objetivo de tener <em>multitasking</em></p><ul class="fragment"><li><strong>Asignar tiempo de (una) CPU frecuentemente a todos los procesos</strong></li></ul><div class="fragment"><img src="../images/images/cpuSched-mp-mt-now.png" alt="Cpusched mp mt now" /></div></section><section id="cpuSched-how"><p>Muchos procesos en estado <em>ready</em></p><p class="fragment">&hellip; ¿qué hacer con ellos?</p><p class="fragment"><strong>¡Colas!</strong></p></section><section id="cpuSched-queues"><p>Colas de <em>scheduling</em></p><p>Múltiples colas</p><img src="../images/figures/01-3_05.pdf.png" width="50%" alt="01 3 05.pdf" /></section><section id="cpuSched-queues-1"><p>El <em>Scheduling</em> puede ser visto como un sistema de <em>manejo de colas</em></p><img src="../images/figures/01-3_06.pdf.png" width="50%" alt="01 3 06.pdf" /><p class="fragment">¿Bajo qué criterio?</p><p class="fragment">$longrightarrow$ <strong>algoritmos de <em>scheduling</em></strong></p></section><section id="cpuSched-levels"><p>Distintos <em>schedulers</em> en un SO</p><ul><li><em>Long-term Scheduler</em>   <span class="fragment">Admite procesos en la <em>cola ready</em>. Determina el <strong>grado de multiprogramación</strong>.</span></li><li><em>Short-term Scheduler</em>  <span class="fragment">Selecciona procesos en la(s) cola <em>ready</em> a ejecutar.</span></li><li><em>Medium-term Scheduler</em> <span class="fragment">Modificación temporal del grado de multiprogramación, haciendo <strong>swapping</strong></span></li></ul><div class="center"><img src="../images/figures/01-3_07.pdf.png" width="50%" alt="01 3 07.pdf" /></div></section><section id="cpuSched-thrsh"><p>¿Y si estamos siempre haciendo <em>Scheduling</em> en vez de ejecutar programas?</p><p class="fragment"><em>Scheduling</em> es importante para proveer <strong>multiprogramación</strong></p><p class="fragment">&hellip; pero <em>scheduling</em> y <em>context switch</em> <strong>son sólo <em>overhead</em></strong></p><ul><li class="fragment">¿Qué pasa si el <em>scheduler</em> demora más tiempo de lo que toma el proceso?</li><li class="fragment">¿Qué pasa si el <em>context switch</em> demora más tiempo de lo que toma el proceso?</li><li class="fragment">¿Qué pasa si se le asigna poco tiempo a cada proceso?</li><li class="fragment">¿Qué pasa si hay muchos procesos <em>ready</em>?</li></ul><blockquote class="fragment">Contención de procesos se refleja en <strong>thrashing</strong></blockquote></section><section id="cpuSched-procLife"><p>Ejecución típica de un proceso:</p><p class="fragment">Dos etapas:</p><ul><li class="fragment"> Uso de CPU (CPU-burst)</li><li class="fragment"> Espera por I/O (I/O-burst)</li></ul><p class="fragment">Procesos suelen estar dominados por uno u otro</p><ul class="fragment"><li class="fragment"> CPU-bound</li><li class="fragment"> I/O-bound</li></ul></section><section id="cpuSched-procLife-fig"><img src="../images/figures/01-6_01.pdf.png" width="25%" alt="01 6 01.pdf" /></section><section id="cpuSched-bursts"><p>¿Cuánto dura típicamente un CPU-burst?</p><p class="fragment">No hay una respuesta única, pero&hellip;</p><p class="fragment">Duración de CPU-burst podría afectar el algoritmo de <em>scheduling</em></p><img src="../images/figures/01-6_02.pdf.png" width="50%" alt="01 6 02.pdf" /></section></section><section id="cpuSchedDesign"><h2>Tipos de <em>Scheduling</em></h2><section id="cpuSchedDesign-decisions"><p>Hay que tomar decisión de <em>scheduling</em> cuando:</p><ol class="fragment"><li>Proceso pasa de <strong>Running</strong> a <strong>Waiting</strong></li><li>Proceso pasa de <strong>Running</strong> a <strong>Ready</strong></li><li>Proceso pasa de <strong>Waiting</strong> a <strong>Ready</strong></li><li>Proceso termina</li></ol></section><section id="cpuSchedDesign-decisions-1"><p>Dos tipos de <em>scheduling</em></p><ul><li class="fragment"><em>Scheduling</em> con expropiación (<strong>preemptive</strong>)</li><ul><li class="fragment">Requiere interrupciones por <em>timer</em></li><li class="fragment">Requiere cuidados de sincronización</li></ul><li class="fragment"><em>Scheduling</em> sin expropiación (<strong>non-preemptive</strong>)</li><ul><li class="fragment">Requiere cooperación de los procesos (deben devolver la CPU pronto)</li><li class="fragment">Así que un programa puede (intencionalmente o no) tomar control permanente de la CPU</li><li class="fragment">Permiten un diseño más simple de Programas y Scheduler</li><ul><li class="fragment">Usado en Windows 3.1, MacOS (antes de X)</li><li class="fragment">También se conoce como <em>scheduling cooperativo</em></li></ul></ul></ul></section><section id="cpuSchedDesign-criteria"><p>Criterios de <em>scheduling</em></p><p class="fragment">¿Qué algoritmo puede ser mejor?&hellip; <span class="fragment">depende</span></p><ul class="fragment"><li CPU="" Uso="" de="">     Mantener la CPU lo más usada posible</li><li Throughput="">     Cantidad procesos atendidos por unidad de tiempo</li><li Turnaround="" time="">Tiempo total de un proceso, incluyendo esperas (wall-clock time)</li><li Waiting="" time="">   Tiempo de espera de un proceso en estado <strong>Ready</strong></li><li Response="" time="">  Importante para sistemas interactivos</li></ul><p class="fragment">¿Qué tiempo es mejor minimizar?&hellip;</p><p class="fragment">¿Tiempo promedio? ¿Tiempo máximo? ¿Varianza?</p></section></section><section id="cpuSchedAlgs"><h2>Algoritmos de <em>Scheduling</em></h2></section><section id="cpuSchedAlgs-fcfs"><h2><em>First-Come First-Served</em> (FCFS)</h2><p>El más simple: una cola FIFO</p><p>Ejemplo: Procesos en cola: $P=\{P_1,P_2,P_3\}$, con tiempos de ejecución (<em>burst-time</em>)
     $T=\{T_1=24,T_2=3,T_3=3\}$ en milisegundos</p><ul><li class="fragment"> Tiempo promedio de espera, para el orden $P_1, P_2, P_3$ <span class="fragment">$\to 17$ms</span></li><li class="fragment"> Tiempo promedio de espera, para el orden $P_2, P_3, P_1$ <span class="fragment">$\to 3$ms</span></li></ul><p class="fragment">Non-preemptive</p><ul><li class="fragment"> +Simple</li><li class="fragment"> -Poco predecible. Procesos CPU-bound pueden bloquear a los I/O-bound, bajo una secuencia "desafortunada" de llegada</li></ul></section><section id="cpuSchedAlgs-sjf"><h2><em>Shortest-Job First</em> (SJF)</h2><section id="cpuSchedAlgs-sjf-init"><p>El más corto primero</p><p class="fragment">Ejemplo: Procesos en cola: $P=\{P_1,\cdots, P_4\}$, 
                                   $T=\{T_1=6,T_2=8,T_3=7,T_4=3\}$</p><ul class="fragment"><li> Tiempo promedio de espera: <span class="fragment">$\to 7$ms</span></li><li> Con FCFS:                  <span class="fragment">$\to 10.25$ms</span></li></ul><p></p><ul class="fragment"><li> +¡Óptimo! en tiempo de espera promedio (demostrable)</li><li> -¿Cómo saber cuánto se tomará cada proceso?</li><ul><li class="fragment"> En <em>long-term scheduling</em> usuarios pueden especificar tiempo máximo</li><li class="fragment"> En <em>short-term scheduling</em> hay que aproximarlo</li></ul></ul></section><section id="cpuSchedAlgs-sjf-appr"><p>Supuesto: el próximo <em>burst</em> durará lo mismo que el anterior</p><p class="fragment">Método de aproximación: <strong>promedio exponencial</strong> (<em>exponential average</em>) sobre los <em>burst</em> anteriores</p><div class="fragment"><p>Sea $t_n$ el tiempo que tomó el $n$-ésimo <em>burst</em>, y $\tau_{n+1}$ el valor predicho.</p><p>Se define, con $\alpha \in [0, 1]$:</p><p>$$ \tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n $$</p></div><p class="fragment">$\alpha$ determina "el peso de la historia":</p><ul><li class="fragment">$ \alpha=0 \Rightarrow \tau_{n+1} = \tau_n $</li><li class="fragment">$ \alpha=1 \Rightarrow \tau_{n+1} = t_n    $</li></ul><div class="fragment"><p>Expansión:</p><p>$$\tau_{n+1} = \alpha t_n + (1-\alpha)\alpha t_{n-1} + \cdots + (1-\alpha)^j \alpha t_{n-j} + \cdots (1-\alpha)^{n+1}\tau_0$$</p></div></section><section id="cpuSchedAlgs-sjf-appr-1"><p>$$\alpha = \frac{1}{2}, \tau_0=10$$</p><img src="../images/figures/01-6_03.pdf.png" width="50%" alt="01 6 03.pdf" /></section><section id="cpuSchedAlgs-sjf-add"><p>¿Qué hacer cuando llega un proceso nuevo?</p><div class="fragment"><p>Decidir en base al <strong>tiempo restante</strong></p><p>Ejemplo</p><blockquote class="fragment">$P=\{P_1,P_2,P_3,P_4\}$,
tiempos de llegada $\{0,1,2,3\}$
$T=\{8,4,9,5\}$  </blockquote></div><ul class="fragment"><li>Ejecución <em>preemptive</em>:     <span class="fragment">$\to 6.50$ms </span></li><li>Ejecución <em>non-preemptive</em>: <span class="fragment">$\to 7.75$ms</span></li></ul></section></section><section id="cpuSchedAlgs-pri"><h2><em>Scheduling</em> con prioridades</h2><section id="cpuSchedAlgs-pri-init"><p class="fragment">Cada proceso tiene asociada una <strong>prioridad</strong></p><ul class="fragment"><li> Se atienden por orden de <strong>prioridad</strong></li><li> Prioridades iguales: FCFS</li><li> SJF es un <em>caso particular</em> de este algoritmo (¿por qué?)</li><li> Muchos criterios para definir prioridades</li></ul><p class="fragment">Puede ser <em>non-preemptive</em> o <em>preemptive</em> (si llega uno con mayor prioridad, ejecuta de inmediato)</p><ul><li class="fragment"> -Inanición de los que tengan baja prioridad</li></ul></section></section><section id="cpuSchedAlgs-rr"><h2><em>Round-Robin</em> (RR)</h2><section id="cpuSchedAlgs-rr-init"><p class="fragment">Ideal para <em>time-sharing</em></p><ul class="fragment"><li> +Cada proceso recibe $1/n$ de CPU, para $n$ procesos</li><li> +Ningún proceso espera más de $(n-1)\times q$ para ejecutar</li><li> Altamente dependiente de la elección de $q$ (puede degenerar a FCFS)</li></ul></section></section><section id="cpuSchedAlgs-mlq"><h2><em>Multi-level queue</em> (MLQ)</h2><section id="cpuSchedAlgs-mlq-init"><p>Múltiples colas, divididas por tipo de proceso.</p><img src="../images/figures/01-6_06.pdf.png" width="40%" alt="01 6 06.pdf" /><p class="fragment">Varias alternativas:</p><ul><li class="fragment"> Prioridades entre colas, FCFS dentro de cada cola</li><li class="fragment"> RR entre colas, con quántums diferenciados</li></ul></section><section id="cpuSchedAlgs-mlfq"><p>Las colas pueden asignarse dinámicamente: <span class="fragment"> Colas Multinivel con Feedback (MLFQ)</span></p><img src="../images/figures/01-6_07.pdf.png" width="30%" alt="01 6 07.pdf" /><ul><li class="fragment"> Colas con quántum diferenciado.</li><li class="fragment"> Proceso que no terminan en su quántum pasan a cola inferior</li><li class="fragment"> Proceso que entregan la CPU permanecen la misma cola</li><li class="fragment"> Dentro de cada cola, <em>scheduling</em> es FCFS</li><li class="fragment"> Favorece procesos con CPU <em>burst</em> cortos</li><li class="fragment"> Eventualmente se puede promover de nivel a los que han esperado más</li></ul></section></section><section id="cpuSchedAlgs-mp"><h2><em>Scheduling</em> en multi-procesador</h2><section id="cpuSchedAlgs-mp-init"><p>Para un procesador no hay una mejor solución &hellip;</p><p class="fragment">para múltiples procesadores es más difícil</p><ul><li class="fragment">Modo asimétrico: distintos tipos de procesos a distintos cores</li><li class="fragment">Modo simétrico (SMP). Ampliamente soportado: Windows, Linux, MacOSX</li><ul class="fragment"><li class="fragment"> ¿colas por procesador o cola única?</li><li class="fragment"> evitar que dos procesadores ejecuten el mismo proceso</li></ul></ul></section><section id="cpuSchedAlgs-mp-afinity"><p>Es más fácil seguir ejecutando en el mismo núcleo que en otro.</p><p class="fragment"><strong>Processor Affinity</strong></p><ul class="fragment"><li>Considera efectos de <em>cache</em></li><li>Evita perder el chache L1 y ensuciar el resto</li></ul><p class="fragment">Pero es mejor ejecutar en otro si está libre.</p><p class="fragment"><strong>Load Balancing</strong></p><ul><li class="fragment">Intenta homogeneizar la carga en los procesadores.</li><li class="fragment">Si hay procesadores desocupados, algunos procesos son migrados a ellos.</li><li class="fragment">Modo <em>push</em> ó <em>pull</em></li><li class="fragment">Hay núcleos más cercanos que otros (físicamente y por cache)</li></ul><br /><p class="fragment">Son objetivos conflictivos ¿cuál escoger y cuándo?</p></section></section><section id="cpuSchedAlgs-currentOS"><h2><em>Scheduling</em> en algunos SO</h2><section id="cpuSchedAlgs-currentOS_"></section><section id="cpuSchedAlgs-win"><h2>Windows</h2><ul><li class="fragment"> 3.1, 95, 98. Preemptive para 32-bit. Cooperative para 16-bit.</li><li class="fragment"> NT-based. MLFQ con 32 prioridades.</li><ul><li class="fragment"> 16 prioridades normales</li><li class="fragment"> 16 prioridades <em>Real-Time</em></li><li class="fragment"> S.O. puede modificar prioridad para mejorar interactividad</li></ul></ul></section><section id="cpuSchedAlgs-macOS"><h2>Mac OS</h2><ul><li class="fragment"> Hasta MacOS 9: cooperativo. RR entre procesos.</li><li class="fragment"> MacOSX: MLFQ con 4 prioridades</li><ul><li class="fragment"> Normal</li><li class="fragment"> System high-priority</li><li class="fragment"> Kernel mode only</li><li class="fragment"> Real-time</li></ul></ul></section><section id="cpuSchedAlgs-linux"><h2>Linux</h2><ul><li class="fragment"> Linux 2.4. $O(n)$ <em>scheduler</em>. MLFQ. <em>Quantum</em>s no usados por completo se agregan a la siguiente ronda.</li><li class="fragment"> Linux 2.6.0 a 2.6.22. $O(1)$ <em>scheduler</em>. Mejor soporte para SMP, mal soporte para tareas interactivas.</li><ul><li class="fragment"> Tiempo de selección independiente del número de procesos</li></ul><li class="fragment"> Linux 2.6.23&hellip;+4.5 <em>Completely Fair Scheduler</em> (CFS).</li></ul><p class="fragment"> Se puede cambiar el scheduler de CPU y (spoiler) el de cada disco.</p><ul><li class="fragment"> Para escritorios muchos prefieren el <em>Brain Fuck Scheduler</em> (BFS).</li></ul></section></section><section id="summary"><h2>Resumen: <em>Scheduling</em></h2><section id="summary_"><ul><li class="fragment"> <em>Scheduler</em> permite seleccionar el próximo proceso del conjunto <em>ready</em></li><li class="fragment"> Debe ser una decisión rápida</li><li class="fragment"> Diferentes métricas para comparar algoritmos de <em>scheduling</em></li><li class="fragment"> Algoritmos clásicos:</li><ul><li class="fragment"> FCFS: simple, tiempo de espera impredecible</li><li class="fragment"> SJF: óptimo en tiempo de espera, difícil de predecir</li><li class="fragment"> RR: mejor para <em>time-sharing</em>, depende de $q$</li><li class="fragment"> Prioridades: con expropiación, apropiado para <em>real-time</em></li><li class="fragment"> Multicolas, MLFQ: flexible y base para <em>schedulers</em> reales</li></ul><li class="fragment"> <em>Scheduling</em> para multiprocesadores</li><ul><li class="fragment"> Arquitecturas SMP requiere <em>tradeoff</em> entre afinidad y balance de carga</li></ul></ul></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        //mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        //Migrated. Check here: https://www.mathjax.org/cdn-shutting-down/
        mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>