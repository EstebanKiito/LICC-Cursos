<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Capa de Red</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>Capa de Red</h1><p>Semestre 2022-1<br/>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación<br/>Pontificia Universidad Católica de Chile</p></section><section><h2>Capa de Red</h2><section><blockquote style="background:#B7E1CD;"><b>Objetivo</b>: Transmisión de paquetes desde <b>emisor</b> a <b>receptor</b></blockquote><div style="width:65%; vertical-align:middle; display:inline-block;"><div style="text-align:left;"><b>Unidad de transmisión</b>: <i>paquete</i> o <i>datagrama</i></div><div style="text-align:left;">Dos problema principales:</div><ul><li><b>Direccionamiento</b>. Determinar la ubicación del nodo destino en la red.</li><ul style="font-size:24px;"><li>Cada miembro (host) debe poseer una dirección única</li><li>La información del paquete debe ser suficiente para encontrar al destino</li></ul><li><b>Enrutamiento</b>. Coordinar <i>routers</i> para que el paquete llegue al destino.</li><ul style="font-size:24px;"><li>Algoritmos para determinar <i>rutas</i>: algoritmos de enrutamiento (<i>routing</i>)</li><li><i>Routing</i> debe ser eficiente</li></ul></ul></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-net-layer.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><blockquote style="background:#B7E1CD;"><b>Objetivo</b>: Transmisión de paquetes desde <b>emisor</b> a <b>receptor</b></blockquote><div style="width:65%; vertical-align:middle; display:inline-block;"><div style="text-align:left;"><i>Routers</i> son dispositivos de <i>almacenamiento y reenvío</i>: <b>store-and-forward</b>/</div><br /><ul><li><b>Forwarding</b>. Decisión local de un <i>router</i></li><ul style="font-size:28px;"><li>Cada <i>router</i> determina el próximo camino (salida) de un paquete mirando su <i>dirección de destino</i></li><li><i>Router</i> usa <i>forwarding tables</i></li></ul><li><b>Enrutamiento (<i>routing</i>)</b>. Decisión distribuida entre <i>routers</i></li><ul style="font-size:28px;"><li><i>Routers</i> ejecuta un <i>algoritmo de routing</i>.</li><li><i>Algoritmo de routing</i> permite llenar las <i>forwarding tables</i></li></ul></ul></div><div style="width:35%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-forward.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section></section><section><h2>Modos de Conexión</h2><section><h3>Virtual Circuit Network</h3><div style="width:55%; vertical-align:middle; display:inline-block;"><div>Esquema de red telefónica</div><ul style="font-size:28px;"><li>Setup del VC. Permite reserva ancho de banda.</li><li>Data transfer.</li><li>Destrucción del VC.</li><li><i>Router</i> mantiene <i>estado de la conexión</i>: <b>Connection-oriented</b></li></ul><br /><div>Garantiza ancho de banda durante la conexión</div><ul style="font-size:28px;"><li>Ancho de banda desperdiciado mientras no se transmiten datos</li><li>Poco flexible a congestiones</li><li>Limita la cantidad de VC simultáneos</li></ul></div><div style="width:45%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-vc3.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Datagram network</h3><div style="width:55%; vertical-align:middle; display:inline-block;"><div>Esquema de Internet</div><ul style="font-size:28px;"><li>Cada paquete lleva la dirección de destino.</li><li><i>Routers</i> reenvían de acuerdo a su <i>forwarding table</i></li><li>Paquetes podrían tener distintos caminos.</li><li><i>Routers</i> no saben de caminos ni estado. <b>Connectionless</b>.</li></ul><br /><div>No garantiza ancho de banda</div><ul style="font-size:28px;"><li>Flexible ante congestión</li><li>Permite ocupar de mejor manera el ancho de banda</li></ul></div><div style="width:45%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-dg1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section></section><section><h2>Direccionamiento de Red</h2><section><h3>¿Qué hay en <i>forwarding table</i>?</h3><div><i>Router</i> debe tener respuesta para cada dirección posible</div><ul style="font-size:28px;"><li>Destinos para cada dirección posible. Usualmente <i>forwarding table</i> contiene <b>prefijos</b></li></ul><div>Ejemplo con rangos de direcciones de 32-bit</div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-dg3.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-dg2.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div></section><section><h3>¿Cómo un mensaje encuentra su destinatario?</h3><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Gracias al <b>datagrama (paquete) IP</b></div><ul><li>Longitud típica < 1500 byte.</li><li>TTL: Time-to-live. Cantidad máxima de saltos (<i>hop</i>s).</li><li>Si no hay <i>options</i>, header es de 20 byte.</li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-ip.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Fragmentación</h3><div>Cada enlace puede tener distintas MTU (<i>Máximum Transfer Unit</i>)</div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-fragmentation.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Al encontrar enlace con menor MTU:</div><ul style="font-size:28px;"><li><i>Router</i> fragmenta el datagrama.</li><li><i>Router</i> envía fragmentos con mismo identificador</li><li><i>Router</i> en el otro extremo del enlace lo reensambla.</li></ul><img src="../images/figures/09-fragmentation2.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Dirección IP</h3><div style="width:60%; vertical-align:middle; display:inline-block;"></div><div>Direcciones de $32$ bit $= 4$ byte (IPv4). </div><ul style="font-size:32px;"><li>$2^{32} = 4294967296$ direcciones.</li><li><b>Dotted-decimal notation</b>. Grupo de $8$ bit. ($0$ a $255$).</li><li>$146.155.13.45$ es $10010010.10011011.00001101.00101101$</li><li>Dirección <b>única globalmente</b> (casi)</li></ul><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-subnets.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Subredes</h3><div>Conjunto de nodos conectados a un <i>router</i></div><div style="width:60%; vertical-align:middle; display:inline-block;"><div style="text-align:left;">Notación <b>CIDR: Classless Interdomain Routing</b> (RFC4632)</div><div><code>a.b.c.d/x</code></div><ul style="font-size:32px;"><li>Ejemplo: <code>223.1.1.0/24</code>.</li></ul><br /><br /><div style="text-align:left;">Primeros $x$ bit definen la <b>subred</b>.</div><ul style="font-size:32px;"><li>Ejemplo: <code>223.1.1.0/24</code></li><li>Máscara <code>/24</code>, ó <code>255.255.255.0</code></li><li>IP <code>&</code> máscara $\to$ <i>subred</i></li></ul><br /><br /><div style="text-align:left;"> Últimos $32-x$ bit definen el <b>host</b> dentro de la subred/</div><ul style="font-size:32px;"><li>Ejemplo: <code>223.1.1.40/24</code></li><li>Máscara es: 255.255.255.0</li><li>Subred es: 223.1.1.0</li><li>Host es: 223.1.1.40</li></ul></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-subnets.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Subred: <code>146.155.13.0/24</code></div><br /><ul><li>24 bits para subred. 8 bit para host. </li><li>Tamaño de subred: $2^8 = 256 - 2 = 254$ hosts máximo.</li><li>Nombre de subred: Bits de <i>host</i> en 0. </li><ul><li><code>146.155.13.0</code></li></ul><li>Dirección broadcast: Bits de <i>host</i> en 1.</li><ul><li><code>146.155.13.255</code></li></ul><li>Máscara (mask): $x$ bit en 1, $32-x$ bit en 0.</li><ul><li><code>255.255.255.0</code></li></ul></ul><br /><br /><div>Google: <a href="http://jodies.de/ipcalc">IP calculator</a></div></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-cidrexample.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div style="width:60%; vertical-align:middle; display:inline-block;"><div>Cada <i>router</i> posee una dirección IP en cada salida</div><ul style="font-size:24px;"><li><i>Switches</i>, por otro lado, <b>NO</b> poseen dirección IP</li><li><i>Switches</i> son dispositivos de capa 2 (enlace)</li></ul><br /><br /><div>Cada grupo de <i>hosts</i> conectados a un <i>router</i> forma una subred</div><br /><br /><div>Ejemplo muestra 6 subredes</div></div><div style="width:40%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-subnets2.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Subredes y direcciones especiales</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Direcciones reservadas</b></div><ul><li><code>0.0.0.0</code>. Dirección de host actual (sólo sirve como origen). "Todas las IPs locales".</li><li><code>127.0.0.1</code>. Dirección <i>loopback</i> (localhost)</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Subredes reservadas</b></div><ul><li>Red local: <code>0.0.0.0/8</code></li><li>Red loopback: <code>127.0.0.0/8</code></li><li>Redes privadas (RFC1918):</li><ul><li><code>10.0.0.0/8</code></li><li><code>172.16.0.0/12</code></li><li><code>192.168.0.0/16</code></li></ul></ul></div></section><section><h3>Classful routing</h3><div>Old school. En el principio existían clases de redes.</div><div><img src="../images/figures/07-ip-subnets-clases.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div></section><section><h3>Asignación de direcciones</h3><div style="text-align:left;">ISPs asignan bloques de direcciones a organizaciones, y publican sus bloques. </div><div style="text-align:left;">Organizaciones pueden crear nuevas subredes dentro de su bloque</div><div><img src="../images/figures/09-isps.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Asignación de direcciones</h3><div>¿Quién administra direcciones? ¿Cómo las obtiene el ISP?</div><div>ICANN: Internet Corporation for Assigned Names and Numbers</div><div>ICANN asigna direcciones a "regional Internet registries"</div><div><img src="../images/figures/09-regions.png" style="background:none; border:none; box-shadow:none;" width="70%" /></div></section></section><section><h2>Direcciones dinámicas: DHCP</h2><section><h3>Dynamic Host Configuration Protocol</h3><div>Pocas veces configuramos nuestra IP. DHCP es un protocolo <i>plug-and-play</i> (RFC2131)</div><div><img src="../images/figures/09-dhcp1.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div></section><section><h3>Dynamic Host Configuration Protocol</h3><div style="width:70%; vertical-align:middle; display:inline-block;"><div>Protocolo cliente-servidor de 4 etapas</div><ul><li>DHCP Server Discovery. Cliente envía <b>DHCP discover message</b>. Destino 255.255.255.255.</li><li>DHCP Server Offer(s). Server envía <b>DHCP offer message</b>. Destino 255.255.255.255.</li><li>DHCP Request. Cliente envía <b>DHCP request message</b>.</li><li>DHCP ACK. Server envía <b>DHCP ACK message</b>.</li></ul></div><div style="width:30%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-dhcp2.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section></section><section><h2>NAT: Network Address Translation</h2><section><div style="text-align:left;">Oficinas pequeñas y casas forman una LANs. Pero ISP provee cantidad limitada de IPs (a veces una).</div><div style="text-align:left;">NAT (RFC2663, RFC3022) permite multiplexar direcciones IP en redes privadas (RFC1918).</div><div><img src="../images/figures/09-nat1.png" style="background:none; border:none; box-shadow:none;" width="70%" /></div></section><section><h3>NAT Traversal</h3><div>¿Cómo contactar un servicio detrás de NAT?</div><div>Protocolo UPnp (Universal Plug and Play) permite establecer <i>mappings</i> dinámicos</div><div>Mapping: (privateIP, privatePort) $\to$ (publicIP, publicPort)</div><div><img src="../images/figures/07-nat-3.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><h3>Anti NATs</h3><div>NAT es ampliamente usado. Pero tiene detractores.</div><div style="text-align:left;"><b>Detractores</b>:</div><ul><li>Números de puerto son para <b>procesos</b>. No para <b>hosts</b>.</li><li><i>Routers</i> son de capa 3. NAT requiere que modifiquen puertos. Puerto no son de capa 3.</li><li>NAT viola el principio de extremo-a-extremo. Comunicación sin modificaciones intermedias.</li><li>NAT es un parche. Con IPv6 ya nunca deberíamos necesitar NAT.</li></ul></section></section><section><h2>ICMP</h2><section><h3>Internet Control Message Protocol</h3><div>RFC 792. Usado para mensajes de diagnóstico y control en capa de red.</div><ul><li>Se transmiten como <i>payload</i> en paquetes IP. Campo <i>upper-layer protocol</i> indica ICMP.</li><li>ICMP contiene dos campos: (<i>ICMP type</i>, <i>ICMP code</i>)</li></ul><div><img src="../images/figures/09-icmps.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><h3>Internet Control Message Protocol</h3><div>Mensajes (8,0) y (0,0): <code>echo request</code> y <code>echo reply</code></div><div>Programa <code>traceroute</code> usa mensajes ICMP con distintos TTL.</div><div><img src="../images/figures/09-icmps.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section></section><section><h2>IPv6</h2><section><div style="text-align:left;">En 1990s, la IEFT se dio cuenta que IPv4 no era suficiente. Empieza el desarrollo de IPv6.</div><div style="text-align:left;">Febrero 2011. IANA asigna último bloque IPv4.</div><div style="text-align:left;">Header IPv6: 40 byte. Prioridad es agilizar el procesamiento.</div><div><img src="../images/figures/09-ipv6.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div><ul><li>IPv6 no considera fragmentación intermedia. Solo en los extremos. ICMP <code>Packet too big</code>.</li><li>IPv6 no usa <i>checksum</i> del header. </li><li>ICMPv6 agrega mensajes adicionales.</li></ul></section><section><div>¿Cómo hacemos la transición?</div><div style="text-align:left;">Routes IPv6 puede ser <i>backwards compatible</i>, pero routers IPv4 no.</div><ul><li>Establecer un día de cambio mundial (<i>flag day</i>). Se intentó hace 25 años para NCP a TCP.</li><li>Usar routers <i>dual-stack</i>, IPv6/IPv4. Algunos campos se pueden perder en la conversión</li></ul><div><img src="../images/figures/09-ipv6-1.png" style="background:none; border:none; box-shadow:none;" width="70%" /></div></section><section><div style="text-align:left;">Otra solución: <b>tunneling</b></div><div><img src="../images/figures/09-ipv6-2.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section></section><section><h2>Algoritmos de <i>Routing</i></h2><section><blockquote style="background:#B7E1CD;"><b>Objetivo:</b> conseguir que el paquete llegue desde un <i>router</i> de origen a un <i>router</i> de destino</blockquote><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Conjunto de <i>routers</i> se modela como un grafo $G=(V,E)$</li><li>Costo entre conexiones: ancho de banda, congestión, costo, distancia, ...</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-routers-1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div>Dos tipos de algoritmos</div><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li><b>Algoritmos centralizados</b></li><ul style="font-size:28px;"><li>Nodos conocen la información completa de la red. </li><li>Algoritmos <b>Link-State (LS)</b>.</li></ul><br /><li><b>Algoritmos decentralizados</b></li><ul style="font-size:28px;"><li>Cálculo iterativo y distribuido entre nodos, sin conocer la topología completa.</li><li>Algoritmos de <b>Distance-Vector (DV)</b></li></ul></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-routers-1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>Link-State Routing</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Cada nodo envía su información de conectividad (vecinos y costos) a sus vecinos</li><li>Información se comunica a los demás vía <i>flooding</i></li><li>Cuando todos tienen información de la topología, cada uno calcula las rutas más cortas</li><li>Algoritmo de Dijkstra (1957)</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-ls-dijkstra.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Cada nodo envía su información de conectividad (vecinos y costos) a sus vecinos</li><li>Información se comunica a los demás vía <i>flooding</i></li><li>Cuando todos tienen información de la topología, cada uno calcula las rutas más cortas</li><li>Algoritmo de Dijkstra (1957)</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-routers-1.png" style="background:none; border:none; box-shadow:none;" width="65%" /><img src="../images/figures/09-ls-dijkstra-2.png" style="background:none; border:none; box-shadow:none;" width="100%" /><div style="font-size:24px;">Tabla de <i>routing</i> para nodo <i>u</i></div></div></section><section><h3>Distance Vector (DV) algorithm</h3><div style="width:50%; vertical-align:middle; display:inline-block;"><div>Distribuido, asíncrono, iterativo. Basado en ecuación de Bellman-Ford</div><div>$d(x,y) = min_v\{c(x,v) + d(v,y)\}$</div><ul style="font-size:28px;"><li>Cada nodo mantiene una tabla de la mejor ruta a sus vecinos</li><li>Cada nodo comparte su tabla con sus vecinos</li><li>Cuando la información se ha propagado a todos los nodos, cada uno conoce las mejores rutas</li><li>Diferencia con LS: se propaga información de rutas, en lugar de enlaces</li></ul><br /><br /><div>Funciona de manera distribuida</div><ul style="font-size:28px;"><li>Se gatilla ante cambios locales de costos</li><li>Se gatilla al recibir mensajes de vecinos</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-dv-1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div style="width:50%; vertical-align:middle; display:inline-block;"><div>Distribuido, asíncrono, iterativo. Basado en ecuación de Bellman-Ford</div><div>$d(x,y) = min_v\{c(x,v) + d(v,y)\}$</div><ul style="font-size:28px;"><li>Cada nodo mantiene una tabla de la mejor ruta a sus vecinos</li><li>Cada nodo comparte su tabla con sus vecinos</li><li>Cuando la información se ha propagado a todos los nodos, cada uno conoce las mejores rutas</li><li>Diferencia con LS: se propaga información de rutas, en lugar de enlaces</li></ul><br /><br /><div>Funciona de manera distribuida</div><ul style="font-size:28px;"><li>Se gatilla ante cambios locales de costos</li><li>Se gatilla al recibir mensajes de vecinos</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-dv-2.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div></section><section><div>Comportamiento ante cambios. $D_y(x)=4$, $D_y(z)=1$, $D_z(y)=1$, $D_z(x)=5$</div><div><img src="../images/figures/09-dv-change.png" style="background:none; border:none; box-shadow:none;" width="65%" /></div><ul><li>Disminuciones (buenas noticias) se propagan rápidamente</li><li>Aumentos (malas noticias) se propagan lentamente. <i>Count-to-infinity</i></li><li>¿Como evitarlo? Anunciando ruta infinita. <i>Poisoned-reverse</i></li></ul></section><section><div>Link-State vs Distance Vector</div><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Link State</b></div><ul><li>$N$ nodos, $E$ enlaces: $O(NE)$ mensajes</li><li>$O(N^2)$ complejidad en cada nodo</li><li>Ante errores, se propaga ausencia de enlace local.</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Distance Vector</b></div><ul><li>Se ejecuta en paralelo y solo se propaga la ruta a los vecinos.</li><li>Ante errores, se propaga el error.</li><li>Puede converger muy lentamente. Tiempo de convergencia indeterminado.</li></ul></div></section><section><div><b>Routing de gran escala</b></div><div>No es factible almacenar tablas para todos los routers de Internet.</div><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Redes están organizadas jerárquicamente.</li><li><i>Routers</i> pertenecen a distintas organizaciones.</li><li><i>Routers</i> pertenecientes al mismo dominio administrativo forman un <b>sistema autónomo</b></li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-as123.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div><b>Routing de Internet</b></div><div style="width:50%; vertical-align:middle; display:inline-block;"><ul><li>Internet se compone de <b>Sistemas Autónomos</b> (AS) interconectados</li><li>Algoritmos <i>intra-AS</i> resuelven ruteo en un subconjunto de la red</li><li>Algoritmos <i>inter-AS</i> ayudan a determinar <i>forwarding tables</i> entre distintos AS</li><li><i>Routers</i> de salida son <b>gateway routers</b></li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-as123.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div><b>Intra-AS</b></div><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>IGP: Interior Gateway Protocols</b> </div><ul><li>RIP: Routing Information Protocol</li><ul style="font-size:24px;"><li>Algoritmo Distance Vector (DV)</li><li>Usado en <i>lower tier</i> ISPs</li></ul><li>OSPF: Open Shortest-Path First</li><ul style="font-size:24px;"><li>Algoritmo Link State (LS)</li><li>Usado en <i>upper tier</i> ISPs</li></ul></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-as123.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><div><b>Inter-AS</b></div><div style="width:50%; vertical-align:middle; display:inline-block;"><div><b>Border Gateway Protocol: BGP</b></div><ul><li>Estándar de facto para comunicación Inter-AS</li><li>Permite a una subred anunciar su existencia a Internet</li><li>Obtener información de <i>reachability</i> de otras subredes</li><li>Propagar información de <i>reachability</i> a nodos internos</li><li>Determinar buenas rutas o otras subredes, en base <i>reachability</i> o políticas específicas.</li></ul></div><div style="width:50%; vertical-align:middle; display:inline-block;"><img src="../images/figures/09-bgp1.png" style="background:none; border:none; box-shadow:none;" width="100%" /></div></section><section><h3>BGP: Border Gateway Protocol</h3><div><img src="../images/figures/09-bgp3.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div>ISPs: A,B,C; Clientes: X,W,Y</div><ul><li>$A$ anuncia a $B$ el camino $(A,W)$</li><li>$B$ anuncia a $X$ el camino $(B,A,W)$</li><li>¿Debería $B$ anunciar a $C$ el camino $(B,A,W)$?</li><ul><li>$B$ no obtiene beneficio por enrutar $(C,B,A,W)$</li><li>$B$ quiere enrutar sólo a sus clientes</li><li>$B$ quiere forzar a que $C$ deba enrutar hasta $W$ a través de $A$</li></ul></ul></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        //mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        //Migrated. Check here: https://www.mathjax.org/cdn-shutting-down/
        mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>