<!DOCTYPE html><html lang="es"><head><!--[if IE]><!--Get a real browser!--><![endif]--><!--Do NOT read this file, the source is available--><meta charset="utf-8" /><title>Capa de Enlace</title><meta content="IIC2333 - Sistemas Operativos y Redes" name="description" /><meta name="author" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/reveal.min.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/css/theme/white.min.css" id="theme" rel="stylesheet" /><link href="https://github.com/frederickf/presentable/raw/master/src/presentable.css" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/css/zenburn.min.css" rel="stylesheet" /></head><body><div class="reveal"><div class="slides"><section><h2>Sistemas Operativos y Redes</h2><h1>Capa de Enlace</h1><p>Semestre 2022-1<br/>Cristian Ruz - cruz@ing.puc.cl</p><p style="padding-top:4em;">Departamento de Ciencia de la Computación<br/>Pontificia Universidad Católica de Chile</p></section><section><h2>Frames, Errores y Control de Flujo</h2><section><div style="text-align:left;"><b>Objetivo</b>: Transmisión de frames a través de un enlace</div><div style="text-align:left;"><b>Unidad de transmisión</b>: <i>frame</i></div><div style="text-align:left;"><b>Servicios</b>:</div><ul><li>Transforme un <i>paquete</i> en <i>frames</i>, y transmitirlo a través de UN enlace.</li><li>Determinar quién puede usar el medio compartidor: <b>Medium Access Control</b> (MAC)</li><li>Transferencia confiable en medios con alta tasa de errores.</li><li>Detección y corrección de errores.</li><li>Qué hacer si un <i>host</i> llega a un punto de saturación y no puede recibir/emitir más frames:
<b>control de flujo</b></li></ul></section><section><div><img src="../images/figures/07-linkhops.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div><div>Cada enlace funciona de manera independiente de los demás.</div></section><section><div>¿Dónde se implementa la capa de red?</div><ul><li><b>Network Interface Card</b> (NIC)</li></ul><div><img src="../images/figures/06-nic.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div></section></section><section><h2>Detección de errores</h2><section><div>¿Cómo saber si un <i>frame</i> llegó con errores?</div><ul><li>Se agregan bits de redundancia que ayuden a detectar algunos errores.</li></ul><div><img src="../images/figures/06-errordetection2.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div></section><section><h3>Parity Check</h3><div>Paridad simple. Errores de un bit</div><div><img src="../images/figures/06-paritysimple2.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div><div>Paridad doble. Detectar <b>y corrige</b> errores de un bit. Detecta errores de 2 bit.</div><div><img src="../images/figures/06-paritydouble2.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div></section><section><h3>Checksums</h3><div>Los bits se toman como secuencias de enteros de $k$ bit ($k < d$), y se suman. </div><div><img src="../images/figures/06-paritysimple2.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div><div>Facil de implementar en software, pero no protege contra muchos errores.</div></section><section><h3>Cyclic Redundancy Check (CRC)</h3><ul><li> $D$: secuencia de $d$ bit de datos</li><li> $R$: secuencia de $r$ bit de comprobación (CRC)</li><li> $G$: patrón conocido $G$, de $r+1$ bit</li></ul><ul><li>La secuencia $\langle D,R \rangle$ debe ser divisible por $G$</li><li>Receptor puede chequear el resto de dividir $\langle D,R \rangle$ por $G$</li><li>Detecta errores de hasta $r$ bit</li></ul><div>Teoría</div><ul><li> $(D\times 2^r) \oplus R = nG$</li><li> $(D\times 2^r) = nG \oplus R$</li><li> $R$ es el resto de la división binaria $\frac{D \times 2^r}{G}$</li></ul><div><img src="../images/figures/06-crc2.png" style="background:none; border:none; box-shadow:none;" width="35%" /></div></section><section><div>Ejemplo: $D=101110$, $G=1001$, determinar $R$</div><div><img src="../images/figures/06-crc3.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div><div>Se envía: $101110011$</div></section></section><section><h2>MAC: Acceso al medio</h2><section><div>Problema de acceso al medio. Presente en medios compartidos (broadcast)</div><ul><li>Partición de canal: tiempo, frecuencia o código</li><li>Acceso aleatorio</li><li>Turnos</li></ul><div><img src="../images/figures/06-macproblem.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><h3>Particionamiento por tiempo: Time-Division Multiple Access (TDMA)</h3><ul><li>Acceso por turnos fijos</li><li>Cada nodo tiene un <i>slot</i> que es múltiplo de un periodo de tiempo</li><ul><li>Con $N$ nodos y <i>slot</i> de tiempo $T$, se hacen rondas de $NT$</li><li>Nodo $i$ durante $[(rN+i)\times T, (rN+i+1)\times T)$</li><li>Con 6 nodos de 5 sec, nodo 0 transmite durante $[0,5), [30,35), [60,65), \ldots$</li></ul></ul><li><i>Slot</i>s no utilizados se pierden</li><div><img src="../images/figures/06-tdma2.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div></section><section><h3>Particionamiento por frecuencia: Frequency-Division Multiple Access (FDMA)</h3><ul><li>División por bandas de frecuencia. (Ej: canales de radio, televisión)</li><li>Cada estación tiene una banda fija asignada</li><li>Bandas no utilizadas quedan inactivas</li></ul><div><img src="../images/figures/06-fdma.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Particionamiento por código: Code-Division Multiple Access (CDMA)</h3><ul><li>Permite que varios usuarios transmitan en la misma frecuencia</li><li>Cada usuario posee un código de transmisión: códigos debe ser ortogonales</li><ul><li>Señal a transmitir: <i>data cliente</i> $ \cdot $ <i>código cliente</i></li><li>Señal recibida: <i>data recibida</i> $ \cdot $ <i>código cliente</i></li></ul></ul></section><section><div><img src="../images/figures/06-cdma11.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><div><img src="../images/figures/06-cdma22.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Acceso aleatorio</h3><div>Protocolos optimistas</div><ul><li>Cada nodo transmite cuando lo desea ocupando todo el ancho de banda disponible</li><li>Si dos o más transmite al mismo tiempo, se produce <b>colisión</b></li><li>Protocolo debe determinar:</li><ul><li>Cómo detectar colisiones</li><li>Qué hacer ante una colisión (cómo recuperarse)</li></ul></ul><li>Protocolos:</li><ul><li>ALOHA particionado</li><li>ALOHA</li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></section><section><h3>ALOHA PARTICIONADO</h3><ul><li>Todos los frames deben tener el mismo tamaño</li><li>El tiempo se divide en particiones del tamaño requerido para transmitir un frame</li><li>Nodos pueden empezar a transmitir sólo al comienzo de estas particiones</li><li>Si dos o más empiezan a transmitir en la misma partición, se detecta <b>colisión</b></li></ul><div>Ante una colisión:</div><ul><li>Cada nodo vuelve a transmitir en la siguiente partición, con probabilidad $p$, hasta que no haya colisiones</li></ul><div><img src="../images/figures/06-alohapart22.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>ALOHA particionado</h3><div><img src="../images/figures/06-alohapart22.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div>Eficiencia</div><ul><li>$N$ nodos con <i>frames</i> a enviar. Probabilidad de enviar $p$.</li><li>Probabilidad que un nodo dado pueda transmitir: $p(1-p)^{N-1}$</li><li>Probabilidad que cualquier nodo pueda transmitir: $Np(1-p)^{N-1}$</li><li>$p^*$ que maximiza $Np(1-p)^{N-1}$</li><li>Maximo valor para esta expresión $\sim 0.368$</li><li>Canal es utilizado a los más el $37\%$ del tiempo</li></ul></section><section><h3>ALOHA</h3><div>No hay sincronización al momento de empezar a transmitir</div><ul><li>Mayor probabilidad de colisiones</li><li>Frame enviado en instante $t_0$ puede colisionar con frames enviados entre $[t_0-1,t_0+1]$</li><li>Eficiencia $\sim 0.18$</li></ul><div><img src="../images/figures/06-aloha2.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Carrier Sense Multiple Access: CSMA</h3><div>No interrumpir a los demás. Emisor escucha antes de transmitir</div><ul><li>Si detecta canal inactivo, envía. Si detecta canal activo, espera hasta dejar de detectar actividad</li><li>Retrasos en la propagación permite que ocurran colisiones</li></ul><div><img src="../images/figures/06-csma2.png" style="background:none; border:none; box-shadow:none;" width="29%" /></div></section><section><h3>CSMA, with Colission Detection: CSMA/CD</h3><ul><li>Detección rápida de colisiones. Aborta en cuanto se detecta colisión, usando <i>jam signal</i></li><li>Usando en LAN (Ethernet): comparando nivel de fuerza de señales. WLAN: difícil de detectar</li></ul><div><img src="../images/figures/06-csma-cd2.png" style="background:none; border:none; box-shadow:none;" width="29%" /></div></section><section><h3>CSMA, with Colission Avoidance: CSMA/CA</h3><ul><li>Si se detecta colisión se espera un tiempo aleatorio (con <i>exponential backoff</i>)</li><li>Se envía un <i>frame</i> ACK para confirmar recepción (CRC correcto)</li></ul><div><img src="../images/figures/06-csma-ca11.png" style="background:none; border:none; box-shadow:none;" width="22%" /></div></section><section><h3>CSMA, with Colission Avoidance: CSMA/CA</h3><div>Pero puede haber <b>terminales ocultos</b></div><div><img src="../images/figures/06-csma-ca22.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>CSMA, with Colission Avoidance: CSMA/CA</h3><div>Complementado con paquetes adicionales: RTS (Request to Send) y CTS (Clear to Send)</div><div><img src="../images/figures/06-csma-ca33.png" style="background:none; border:none; box-shadow:none;" width="25%" /></div></section><section><h3>Protocolos por turnos: Master/Slave (polling)</h3><ul><li>Master invita a los slaves a transmitir (polling)</li><li>Eficiente con terminales ``tontos''</li><li>Alta latencia con muchos slaves</li><li>Punto de falla centralizado</li><li>Usado en Bluetooth</li></ul><div><img src="../images/figures/06-turnos1.png" style="background:none; border:none; box-shadow:none;" width="30%" /></div></section><section><h3>Protocolos por turnos: Token</h3><ul><li>Nodos se pasan un <i>token</i></li><li>Sólo el que tiene el <i>token</i> puede transmitir</li><li>Alta latencia con muchos miembros</li><li>¿Qué pasa si el nodo que tiene el <i>token</i> desaparece?</li></ul><div><img src="../images/figures/06-turnos2.png" style="background:none; border:none; box-shadow:none;" width="20%" /></div><div>FDDI, IEEE 802.5 Token ring</div></section></section><section><h2>Hardware de Capa de Enlace: Switched LANs</h2><section><div><img src="../images/figures/06-switchedlan.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><div>Switched LAN y 4 subredes</div></section><section><h3>Direcciones MAC</h3><div><b>MAC address</b>, o <b>Dirección Física</b>, o <b>Dirección de Hardware</b></div><div><img src="../images/figures/06-macaddress2.png" style="background:none; border:none; box-shadow:none;" width="27%" /></div><div>Identificador único de 48 bit (6 byte). Modificable por software</div><ul><li>24 bit para fabricante, 24 bit para NIC</li><li>Estructura de direccionamiento plana</li><li>FF-FF-FF-FF-FF-FF es dirección de <i>broadcast</i></li></ul></section><section><h3>Address Resolution Protocol (ARP)</h3><div>Tabla ARP contiene asociaciones $\langle \text{IP},\text{MAC},TTL \rangle$</div><ul><li>Cada nodo (host,router, algunos switch) mantiene una tabla ARP</li><li>TTL: Time-To-Live, indica el tiempo que será recordada esa entrada</li></ul><div><img src="../images/figures/06-arp22.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><div><img src="../images/figures/06-arp22.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div><div>Tabla para 222.222.222.220 (comando <code>arp</code>)</div><div><img src="../images/figures/06-arp33.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><div>¿Cómo encontrar una dirección MAC?</div><div><img src="../images/figures/06-arp22.png" style="background:none; border:none; box-shadow:none;" width="40%" /><img src="../images/figures/06-arp-header.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div><ul><li>$C$ quiere comunicarse con $A$, que no está en su tabla</li><li>$C$ envía mensaje <b>ARP Query</b> con IP de $A$ y MAC <code>FF-FF-FF-FF-FF-FF</code></li><li>Todos reciben el mensaje</li><li>Solo $A$ envía mensaje <b>ARP Response packet</b> con su dirección MAC</li><li>$C$ guarda en su tabla ARP la asocación IP(A),MAC(A)</li></ul></section><section><div>Atrevesando subredes: ¿si el mensaje va a otra subred?</div><div><img src="../images/figures/06-arp-subnets2.png" style="background:none; border:none; box-shadow:none;" width="70%" /></div><ul><li><code>111.111.111.111</code> desea enviar <i>frame</i> a <code>222.222.222.222</code></li><li><code>222.222.222.222</code> no está en su tabla ARP (ni en broadcast)</li><li>Envía: $\langle \text{IP}=222.222.222.222, \text{MAC}=? \rangle$.</li><li>Si MAC=<code>49-BD-D2-C7-56-2A</code>, el <i>frame</i> no sale de la subred.</li><li>Debe ser MAC=<code>E6-E9-00-17-BB-4B</code>. <i>Router</i> recibe y pasa a su capa de red.</li><li>Router envía frame con $\langle \text{IP}=222.222.222.222, \text{MAC}=\text{49-BD-D2-C7-56-2A} \rangle$</li></ul></section><section><h3>Ethernet</h3><div>Ampliamente usado para LAN. Original de 1970's. Switched desde 1990's.</div><ul><li>Basado en <b>coaxial</b>: <i>broadcast LAN</i>. Topología de bus.</li><li>Basado en <b>hub</b>: <i>broadcast LAN</i>. Topología estrella.</li><li>Basado en <b>switch</b>. Evita colision. Dispositivo L2. </li></ul><div><img src="../images/figures/06-frame-ethernet.png" style="background:none; border:none; box-shadow:none;" width="80%" /></div></section><section><h3>Frame Ethernet</h3><div><img src="../images/figures/06-frame-ethernet2.gif" style="background:none; border:none; box-shadow:none;" width="70%" /></div><ul><li><i>Data</i>. 46 a 1500 byte. Ethernet MTU: 1500 byte. Jumbo frame $\sim$ 9000 byte.</li><li><i>Destination MAC</i>. Destinatario la procesa solo si es la propia o FF-FF-FF-FF-FF-FF.</li><li><i>Source MAC</i>.</li><li><i>Type</i>. Protocolo: IP, Novell IPX, AppleTalk, ARP</li><li><i>CRC</i>. Ethernet <b>descarta</b> <i>frame</i>s erróneos. No avisa. No confiable.</li><li><i>Preamble</i>. $7 \times $<code>10101010</code>, $1 \times $<code>10101011</code></li></ul></section><section><h3>L2 Switches</h3><div style="text-align:left;">Switch recibe <i>frame</i> y retransmite por el enlace apropiado, <b>basado en MAC</b></div><div style="text-align:left;"><b>Filtering</b>: determine si debe hacer <b>forward</b> o <b>drop</b></div><div style="text-align:left;"><b>Forwarding</b>: determina por cuál enlace retransmitir.</div><div><img src="../images/figures/06-switchedlan.png" style="background:none; border:none; box-shadow:none;" width="45%" /><img src="../images/figures/06-switch-table-22.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div></section><section><h3>Switch Table</h3><div>Switch recibe frame en enlace $x$, con destino MAC = <code>DD-DD-DD-DD-DD-DD</code></div><ul><li>Si no hay entrada para <code>DD-DD-DD-DD-DD-DD</code>, broadcast por todos los enlaces, salvo $x$</li><li>Si hay entrada para <code>DD-DD-DD-DD-DD-DD</code> con enlace $x$, descarta (filtering).</li><li>Si hay entrada para <code>DD-DD-DD-DD-DD-DD</code> con enlace $y \neq x$, reenvía (forwarding).</li></ul><div><img src="../images/figures/06-switchedlan.png" style="background:none; border:none; box-shadow:none;" width="40%" /><img src="../images/figures/06-switch-table-22.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><h3>Switch Table</h3><div>Switch <b>aprenden</b> automáticamente su tabla.</div><ul><li>Tabla inicialmente vacía</li><li>Para cada <i>frame</i> recibido, switch almacena:</li><ol><li><i>source</i> MAC</li><li>enlace de recepción</li><li>tiempo de recepción.</li></ol><li>Después de un <b>aging time</b>, el switch elimina la entrada. Un host puede ser reemplazado, y esta información llega eventualmente al switch.</li><li>Un switch es <b>plug-and-play</b></li></ul><div><img src="../images/figures/06-switch-table-33.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div></section><section><h3>Switch y ciclos</h3><div>Ciclos son malos para el brodcast.</div><div><img src="../images/figures/06-stp-11.png" style="background:none; border:none; box-shadow:none;" width="45%" /></div></section><section><h3>Switches: Spanning Tree Protocol</h3><div>Etapas:</div><ul><li>Elegir un <b>root bridge</b>. En base a una prioridad + identificar (MAC)</li><li>Cada uno (salvo root) elige enlace en dirección al <b>root bridge</b> (RP)</li><li>Cada uno determina sus <b>designated port</b> </li><li>Puertos no usados quedan como <b>blocked</b> (alternativos)</li></ul></section><section><h3>Switches: Spanning Tree Protocol</h3><div>Topología final se autoconfigura como un <i>spanning tree</i></div><div><img src="../images/figures/06-stp-22.png" style="background:none; border:none; box-shadow:none;" width="25%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</img><img src="../images/figures/06-stp-33.png" style="background:none; border:none; box-shadow:none;" width="25%" /></div></section><section><h3>Switch vs Router</h3><div><b>Switch</b> es L2 (decide en base a MAC). <b>Router</b> es L3 (decide en base a IP)</div><div><b>Switch</b> se autoconfigura. <b>Router</b> debe ser configurado.</div><div><b>Switch</b> no resuelve ARP (no conoce IP). <b>Router</b> sí.</div><div><b>Switch</b> es susceptible a <b>switch poisoning</b>, y <b>broadcast storm</b></div><div><img src="../images/figures/06-switch-v-router.png" style="background:none; border:none; box-shadow:none;" width="50%" /><img src="../images/figures/06-switch-v-router-v-hub.png" style="background:none; border:none; box-shadow:none;" width="50%" /></div></section><section><h3>Virtual LANs (VLAN)</h3><div>Switches no proveen <i>suficiente</i> <b>traffic isolation</b>.</div><ul><li>Broadcasts (ARP, DHCP) pueden pasar por todo la red Switched LAN. ¿Sniffers?</li><li>Entonces, usemos múltipes switches.</li><li>Si un usuario se cambia de "grupo de trabajo", se necesita re-cablear al <i>switch</i> correcto</li></ul><div><img src="../images/figures/06-switchedlan.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div></section><section><h3>Virtual LANs (VLAN)</h3><div>Routers solucionan los problemas, pero VLANs están más al alcance.</div><div><img src="../images/figures/06-vlans-22.png" style="background:none; border:none; box-shadow:none;" width="40%" /></div><div>2 VLANs sobre la misma LAN física.</div></section><section><h3>Virtual LANs (VLAN)</h3><div>Ahora queremos VLANs distribuidas entre switches. <b>VLAN trunking</b></div><div><img src="../images/figures/06-vlans-33.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><div><i>Trunking port</i> pertence a TODAS las VLANs y hace <i>forward</i>.</div><div>¿Cómo saber que un <i>frame</i> debe ir de un <i>switch</i> a otro (porque va en la misma VLAN)?</div></section><section><h3>Virtual LANs (VLAN)</h3><div>¡Modificamos el <i>frame</i> ethernet! <b>IEEE 802.1Q</b></div><ul><li><b>Tag Control Information</b> indica número de VLAN</li></ul><div><img src="../images/figures/06-vlans-frame.png" style="background:none; border:none; box-shadow:none;" width="60%" /></div><div>Hay varias formas de construir VLANs</div><ul><li>VLAN en base a puertos (este ejemplo)</li><li>VLAN en base a MAC</li><li>VLAN en base a IP</li></ul></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/js/reveal.min.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    width: 1600,
    height: 900,

    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    math: {
        //mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
        //Migrated. Check here: https://www.mathjax.org/cdn-shutting-down/
        mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
        // config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
    },

    // Optional reveal.js plugins
    dependencies: [

        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },

        // Markdown
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/markdown/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' );} },

        // Highlight <code>
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/highlight/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Mathjax
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/math/math.min.js', async: true },

        // Zoom
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/zoom-js/zoom.min.js', async: true },

        // Speaker Notes
        { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.2.0/plugin/notes/notes.min.js', async: true }

        // Title footer
        //{ src: '/js/plugin/title-footer/title-footer.js', async: true, callback: function() { title_footer.initialize(); } }
    ]
});</script></body></html>